-- MAY 2022 COHORT
-- POSTGRESQL CLASS
-- ABDULLAH BANKOLE

-- SELECT FROM STATEMENT 
-- WE USE THE SELECT STATEMEMT TO FETCH ALL THE COLUMNS, MULTIPLE COLUMNS OR A SINGLE COLUMN FROM A TABLE

-- ALL THE COLUMNS 
-- WE USE ''*'' AFTER THE SELECT STATEMENT TO FETCH ALL THE COLUMNS IN A TABLE

SELECT * FROM ACTOR;

SELECT * FROM FILM;

--FETCH ALL THE COLUMNS IN THE PAYMENT TABLE
-- WENMA
SELECT * FROM PAYMENT;

-- MULTIPLE COLUMNS 
-- SPECIFY THE COLUMN NAMES AFTER THE SELECT STATEMENT 

SELECT CUSTOMER_ID, PAYMENT_ID, AMOUNT FROM PAYMENT;

-- FETCH THE TITLE, RELEASE_YEAR, RATING FROM THE FILM TABLE

SELECT TITLE, RELEASE_YEAR, RATING FROM FILM;

-- SINGLE COLUMN
-- JUST SPECIFY THE COLUMN NAME AFTER THE SELECT STATEMENT 
SELECT TITLE FROM FILM;


-- REMOVING DUPLICATE RECORDS 
-- TO REMOVE DUPLICATE WE USE THE 'DISTINCT' KEYWORD AFTER THE SELECT STATEMENT 
SELECT * FROM FILM;
SELECT RATING FROM FILM;

SELECT DISTINCT RATING FROM FILM; 

-- WHAT ARE THE RELEASE YEARS OF MOVIES IN THE FILM TABLE 
SELECT RELEASE_YEAR FROM FILM;
SELECT DISTINCT RELEASE_YEAR FROM FILM;


-- FILTERING RECORDS 
-- WE USE THE 'WHERE' KEYWORD TO FILTER RECORDS
-- WE FILTER WITH:
-- OPERATORS (>, <, =, !=, AND, OR )
-- FETCH ALL INFO OF CUSTOMERS WHOSE FIRST NAME IS 'JAMIE'
SELECT * FROM CUSTOMER;

SELECT * FROM CUSTOMER 
WHERE FIRST_NAME = 'Jamie';

-- FETCH ALL INFO OF CUSTOMERS WHOSE FIRST NAME IS 'JAMIE' and last name is Rice 

SELECT * FROM CUSTOMER
WHERE FIRST_NAME ='Jamie' AND LAST_NAME = 'Rice';

SELECT * FROM CUSTOMER 
WHERE FIRST_NAME ='Jamie' OR LAST_NAME = 'Rice';

-- FETCH those who paid rental rate amount greater than 10
SELECT * FROM PAYMENT;

SELECT CUSTOMER_ID, AMOUNT FROM PAYMENT
WHERE AMOUNT > 10;

-- WORKING WITH PREDICATES
-- BETWEEN
-- USED TO FITER RANGE OF VALUES 
-- IT IS USED TO REPLACE >= AND <=

-- WE WANT THE CUTOMERID AND AMOUNT PAID BETWEEN $8 AND $10

SELECT * FROM PAYMENT;

SELECT CUSTOMER_ID, AMOUNT  FROM PAYMENT
WHERE AMOUNT BETWEEN 8 AND 10;

-- NOT BETWEEN 
-- A NEGEATION OF BETWEEN 
SELECT CUSTOMER_ID, AMOUNT  FROM PAYMENT
WHERE AMOUNT NOT BETWEEN 8 AND 10;

-- IN 
-- USED TO REPLACE MULTIPLE = SIGN
-- GET ALL INFO OF CUSMTERS WITH ID 361, 362 AND 363

SELECT * FROM CUSTOMER
WHERE CUSTOMER_ID IN (361, 362, 363)

-- WITHOUT IN 
SELECT * FROM CUSTOMER
WHERE CUSTOMER_ID = 361 OR CUSTOMER_ID = 362 OR CUSTOMER_ID = 363;

-- NOT IN 
-- IT A NEGATION OF IN 

SELECT * FROM CUSTOMER
WHERE CUSTOMER_ID NOT IN (361, 362, 363);

-- LIKE
-- USED FOR PATTERN FILTERING 
-- WORKS WITH TWO SUMBOLS 
-- % ==> WILDCARD, AS MANY CHARACTERS AS POSSIBLE
-- _ ==> UNDERSCORE, ONE CHARACTER AT A TIME 

--WE WANT INFO OF CUSTOMER WITH FIRSTNAME STARTING WITH 'JEN'
 SELECT * FROM CUSTOMER
 WHERE FIRST_NAME LIKE 'Jen%';
 
-- get the names of customers whose last name ends with 'is'
SELECT * FROM CUSTOMER
WHERE LAST_NAME LIKE '%is';

-- LIKE IS CASE SENSITIVE 
-- to remove case SENsitivITY, we use ILIKE 
 
 SELECT * FROM CUSTOMER
 WHERE FIRST_NAME ILIKE 'JEn%';

-- SORTING RECORDS 
-- ORDER BY ==> USED TO SORT/ ARRANGE RECORDS 
-- WE CAN SORT BY 
-- ASCENDING ==> LOWEST TO HIGHEST, A-Z, 0-10
-- ASC ==> USED TO SORT IN ASCENDING ORDER
-- DESCENDING ==> HIGHEST TO LOWEST, Z-A, 10-0
-- DESC ==> USED TO SORT IN DESCENDING ORDER 

SELECT FIRST_NAME, LAST_NAME FROM CUSTOMER
ORDER BY LAST_NAME ASC;

SELECT FIRST_NAME, LAST_NAME FROM CUSTOMER
ORDER BY FIRST_NAME DESC;

-- LIMITING RECORDS 
-- LIMIT ==> USED TO LIMIT RECORDS
SELECT FIRST_NAME, LAST_NAME FROM CUSTOMER 
ORDER BY LAST_NAME ASC 
LIMIT 10;

SELECT FIRST_NAME, LAST_NAME FROM CUSTOMER
ORDER BY FIRST_NAME DESC
LIMIT 2;
	
-------------------------------------------------------------
-- DAY 03 

-- ALIASES
-- these are used to rename a column or a table 
-- it uses the AS keyword

select first_name, last_name from customer;

select first_name, last_name AS Surname from Customer;

-- AGGREGATES
-- are use to perform simple statistical operations
-- they operates on a column at a time 
-- they change column name to themselves
-- the column to be aggregated should be within a bracket()
-- THEY ARE USED AFTER THE SELECT STATEMENT 

select amount from payment;
-- MIN
-- This returns the minimum value in a column 
-- find the minimum ampount paid into the company 

SELECT MIN(AMOUNT) FROM PAYMENT;
SELECT MIN(AMOUNT) AS MIN_AMOUNT FROM PAYMENT;

-- MAX
-- This returns the maximum value in a column 

select max(amount) as max_amount from payment;

-- AVG
-- this returns the average mean of values in a column 
select avg(amount) as avg_amount from payment;
-- SUM 
-- this sums up all the values in a column 

select sum(amount) as total_amount from payment;
-- COUNT 
-- the frequency of values in a column 

select count(amount) as count_amount from payment;

-- note: count(columnname) doesnt count null values 
-- to count null values, we use count(*)

-- GROUPING RECORDS
select * from payment;

-- we use the GROUP BY function to group records 
-- it works well with aggregate functions 

-- what is the total amount spent by each customer?
select customer_id,amount from payment;

select customer_id, sum(amount) as total_amount from payment
group by customer_id;

-- How many transactions were performed by each customer?
select customer_id, count(amount) as count_trans from payment
group by customer_id;

-- find the total amount of films we have for each rating

-- AGBAI EMMANUEL 
SELECT RATING, COUNT(FILM_ID) AS TOTAL_FILM FROM FILM
GROUP BY RATING;

-- WENMA 
SELECT RATING, COUNT(TITLE) FROM FILM 
GROUP BY RATING;

-- MICHEAL NMEROLE
SELECT RATING, COUNT(FILM_ID) AS COUNT_FILM FROM FILM 
GROUP BY RATING; 

-- KEMI "KEMO" ONOJA 
SELECT RATING, COUNT(TITLE) AS TOTAL_COUNT FROM FILM 
GROUP BY RATING;

-- JACOB
SELECT FILM.FILM_ID, COUNT(RATING) AS RATING_COUNT FROM FILM 
GROUP BY FILM.FILM_ID; 

SELECT RATING, COUNT(FILM.FILM_ID) AS RATING_COUNT FROM FILM 
GROUP BY RATING; 


-- FILTERING GROUPED RECORDS 
-- HAVING ==> USED TO FILTER GROUPED RECORDS 
-- IT IS VERY SIMILAR TO THE WHERE CLAUSE 
-- IT CAN DO EVERYTHING THE WHERE DOES 
-- YOU CAN USE IT WITH OPERATORS AND PREDICATES 
-- HAVING IS USED TO FILTER GROUPED RECORDS 
-- WHERE IS USED TO FILTER UNGROUPED RECORDS

-- How much has the customers who spent above $200 spent exactly

SELECT CUSTOMER_ID, SUM(AMOUNT) AS TOTAL_AMOUNT FROM PAYMENT
GROUP BY CUSTOMER_ID
HAVING SUM(AMOUNT) > 200;






-- JOINS
-- JOINS ARE USED TO MERGE TWO OR MORE TABLES TOGETHER 
-- THE TABLES ARE JOINED BASED ON THE PRI-FOREIGN KEY RELATIONSHIP

-- TYPES OF JOIN IN POSTGRES ==> 4

-- INNER, LEFT, RIGHT, FULL

-- STEPS FOR JOINING TABLES 
-- 01 IDENTIFY THE TABLES TO JOIN
-- 02 TAKE NOTE OF THE RELATIONSHIP KEYS
-- 03 TAKE NOTE OF THE COLUMNS NEEDED AND THE TABLE EACH COLUMNS RESIDES
-- 04 PUT ALL THE COLUMNS IN A SINGLE  SELECT STATEMENT 
-- 05 ADD THE FIRST TABLE AFER THE FROM STATEMENT 
-- 06 STATE THE JOIN TYPE 
-- 07 ADD THE SECOND TABLE 
-- 08 INTRODUCE THE JOINING CONDITION ==> ON, BASED ON THE RELATIOSHIPS 
-- TO PREVENT AMBIGOUS COLUMNS:
	-- WE ALIAS OUR TABLE NAMES
	-- WE USE TABLE.COLUMNAME SYNTAX ON THE AMBIGOUS COLUMNS, THIS IS SPECIFY THE TABLES THE COLUMNS ARE PRESENT IN

-- INNER 
-- GIVES WHAT IS COMMON TO BOTH SIDES 

-- WE WANT TO KNOW THE NAME OF THE CUSTOMERS THAT PATRONISES US 

-- TABLES TO JOIN ==> CUSTOMER, PAYMENT TABLES
SELECT * FROM CUSTOMER;
--CUSTOMER_ID, FIRST_NAME, LAST_NAME ==> COLUMNS FROM CUSTOMER TABLE 
SELECT * FROM PAYMENT;
--CUSTOMER_ID, PAYMENT_ID, AMOUNT ==> COLUMNS FROM PAYMENT TABLE
-- RELATIONSHIP KEY ==> CUSTOMER_ID 

SELECT CUSTOMER_ID, FIRST_NAME, LAST_NAME, CUSTOMER_ID, PAYMENT_ID, AMOUNT
FROM CUSTOMER
INNER JOIN PAYMENT 
ON CUSTOMER_ID = CUSTOMER_ID 

-- TO PREVENT AMBIGOUS COLUMNS WE ALIASE THE TABLE NAMES 

SELECT C.CUSTOMER_ID, FIRST_NAME, LAST_NAME, P.CUSTOMER_ID, PAYMENT_ID, AMOUNT
FROM CUSTOMER AS C
INNER JOIN PAYMENT AS P
ON C.CUSTOMER_ID = P.CUSTOMER_ID;

--LEFT JOIN
-- PRESERVES THE RECORD ON THE COLUMNS OF THE TABLE IN THE LEFT SIDE 
-- AND ONLY THE MATCHNG RECORD OF THE RIGHT SIDE IS SHOWN
-- THE UNMATCHING ROWS WOULD BE REPRESENTED BY NULL

-- we get the names of the all films and confirm if they Are in the Inventory table or not
-- TABLES ==> FILM, INVENTORY
SELECT * FROM FILM;
-- FILM_ID, TITLE
SELECT * FROM INVENTORY;
-- FILM_ID, INVENTORY_ID
-- RELATIONSHIP KEY ==> FILM_ID 

SELECT F.FILM_ID, TITLE, I.FILM_ID, INVENTORY_ID
FROM FILM AS F
LEFT JOIN INVENTORY AS I
ON F.FILM_ID = I.FILM_ID;



-- DATA DEFINITION LANGUAGES
-- THESE ARE USED TO DEFINE DATABASE OBJECTS 
-- OBJECTS==> DATABASE, SCHEMA, TABLES 

-- CREATE
-- THIS IS USED TO CREATE AN OBJECT (DTABASE OR A TABLE )
-- TO CREATE A DATABASE 
CREATE DATABASE QUANTUM_ANALYTICS;

-- TO CREATE A TABLE
-- STEPS 
-- 01: WE USE THE SYNTAX ==> CREATE TABLE TABLENAME ()
-- 02: WE ADD THE COLUMN NAMES WITHIN THE BRACKETS
-- 03: WE ADD THE DATATYPES TO EACH COLUMN
-- 04: WE SPECIFY RELATIONSHIP (PRIMARY, ETC)
-- 05: WE ADD CONSTRAINT (UNIQUE, NOT NULL, AUTOINCREMENT)
-- PRIMARY KEY ==> UNIQUE + NOT NULL

-- LETS CREATE A TABLE FOR OUR CLASS
CREATE TABLE MAY_COHORT_22 (
	STUDENT_ID INT PRIMARY KEY,
	NAMES VARCHAR(50) NOT NULL,
	GENDER CHAR(1) NOT NULL,
	LOCATION VARCHAR(50) 
);

SELECT * FROM MAY_COHORT_22
-- DROP
-- USED TO DELETE A DATABASE OBJECT (DATABASE, TABLES)
-- DROP DATABASE
DROP DATABASE dvdrental;

drop table may_cohort_22;

-- INSERTING RECORDS INTO TABLES 

-- Miscelleanous
-- Practice! Practice!! Practice!!! 
-- Youtube, W3SCHOOL, SQLSHACK 

-- CONNECT WITH ME LINKEDIN
-- ABDULLAH BANKOLE 
-- https://www.linkedin.com/in/abdullahbankole/

-- THE END 

