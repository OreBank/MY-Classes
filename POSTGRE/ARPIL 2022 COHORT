-- APRIL COHORT POSTGRESQL DAY 02
-- QUANTUM ANALYTICS 

-- 01
-- SELECT - FROM STATEMENT 
-- ==> USED TO RETRIEVE ALL THE COLUMNS, MULTIPLE COLUMNS OR A SINGLE COLUMN FROM A TABLE IN THE DATABASE
-- ALL THE COLUMNS 
-- (*) IS USED AFTER THE SELECT STATEMENT 
 SELECT * FROM FILM;

SELECT * FROM CUSTOMER;

-- MULTIPLE COLUMNS 
-- PUT THE COLUMN NAMES AFTER SELECT STATEMENT 
SELECT FIRST_NAME, LAST_NAME, EMAIL FROM CUSTOMER;

-- SINGLE COLUMN
SELECT EMAIL FROM CUSTOMER;

-- 02 
-- REMOVING DUPLICATES
-- TO REMOVE DUPLICATE ==> DISTINCT 
-- WRITTEN AFTER SELECT 
SELECT * FROM FILM;
SELECT DISTINCT RELEASE_YEAR FROM FILM;

-- GET ME THE DIFFERENT RENTAL DURATIONS WE HAVE 
SELECT RENTAL_DURATION FROM FILM;

SELECT DISTINCT RENTAL_DURATION FROM FILM;

-- 03
--FILTERING THE DATABASE
-- WHERE ==> USED TO FILTER 
-- OPERATORS AND LOGIG
-- =,<,>, <>,! /  AND, OR
-- FIND THE CUSTOMERS WITH JAMIE IM THIER FIRSTNAMES 
SELECT * FROM CUSTOMER;

SELECT FIRST_NAME, LAST_NAME FROM CUSTOMER
WHERE FIRST_NAME = 'Jamie';

-- find all the records of customer whose firstname is jamie and last name is rice 
select * from customer
where first_name = 'Jamie' AND last_name = 'Rice';

-- show who paid the rental rate whcih amout is either less than 1usd or greater than 8usd

select * from payment ;

select customer_id, amount from payment
where amount < 1 or amount > 8     

-- PREDICATES
-- BETWEEN 
-- ==> USED TO FILTER WITHIN RANGES 
-- ==> USED TO REPLACE <= OR >= 
-- WE WANT THE CUSTOMERS WHO PAID BETWEEN 8 AND 10 DOLLARS 
SELECT CUSTOMER_ID, AMOUNT FROM PAYMENT 
WHERE AMOUNT BETWEEN 8 AND 10;

-- WITHOUT BETWEEN
SELECT CUSTOMER_ID, AMOUNT FROM PAYMENT 
WHERE AMOUNT >= 8 AND AMOUNT <=10;

-- NOT BETWEEN 
-- ==> NEGATION OF BETWEEN 
-- WE WANT THE CUSTOMERS WHO DID NOT PAID BETWEEN 8 AND 10 DOLLARS
SELECT CUSTOMER_ID, AMOUNT FROM PAYMENT 
WHERE AMOUNT NOT BETWEEN 8 AND 10;

-- IN 
-- ==> USED TO REPLACE '='
-- GET ALL INFO OF CUSMTERS WITH ID 361, 362 AND 363
SELECT  * FROM CUSTOMER 
WHERE CUSTOMER_ID IN (361, 362, 363);

-- WITHOUT IN 
SELECT  * FROM CUSTOMER 
WHERE CUSTOMER_ID = 361 OR CUSTOMER_ID = 362 OR CUSTOMER_ID = 363;

-- NOT IN 
-- NEGATION OF IN 
SELECT  * FROM CUSTOMER 
WHERE CUSTOMER_ID NOT IN (361, 362, 363);

-- LIKE
-- PATTERN FILTERING 
-- WORKS WITH TWO SYMBOLS 
-- % ==> WILDCARD, AS MANY CHARACTERS AS POSSIBLE 
-- _ ==> UNDERSCORE, ONE CHARACTER AT A TIME 
-- it us case senstive
-- GET THE FULL NAMES OF CUSTOMERS WHOSE FIRSTNAME STARTS WITH JEN
SELECT FIRST_NAME, LAST_NAME FROM CUSTOMER 
WHERE FIRST_NAME LIKE 'Jen%';

SELECT FIRST_NAME, LAST_NAME FROM CUSTOMER 
WHERE FIRST_NAME LIKE 'jen%';

-- get the names of customers whose last name ends with 'is'
select first_name, last_name from customer 
where last_name like '%is';

-- ILIKE 
-- ==> IS JUST A LIKE THAT IS NOT CASE SENSITIVE 
-- ==> IT IGNORES THE CASE SENSITIVITY 
SELECT FIRST_NAME, LAST_NAME FROM CUSTOMER 
WHERE FIRST_NAME ILIKE 'jen%';

select first_name, last_name from customer 
where last_name Ilike '%IS';

-- LIMITING RECORDS 
-- ==> USED TO LIMIT THE AMOUNT ROWS THAT ARE RETRIEVED 

SELECT * FROM FILM
LIMIT 10 ;

SELECT * FROM PAYMENT
LIMIT 100;

-- SORTING RECORDS 
-- ORDER BY ==> IS USED TO SORT RECORDS EITHER IN ASCENDING OR DESCENDING ORDER 
-- ASC ==> ASCENDING == LOWEST TO HIGHEST 
-- DESC ==> DESCENDING == HIGHEST TO LOWEST 

SELECT * FROM PAYMENT 
ORDER BY AMOUNT;

SELECT * FROM PAYMENT 
ORDER BY AMOUNT ASC;

SELECT * FROM PAYMENT 
ORDER BY AMOUNT DESC;

SELECT FIRST_NAME, LAST_NAME FROM CUSTOMER
ORDER BY LAST_NAME DESC;

SELECT FIRST_NAME, LAST_NAME FROM CUSTOMER
ORDER BY FIRST_NAME ASC;

-- FIRST 10 CUSTOMERS SORTED IN ASCENDING BY FIRSTNAME 
SELECT FIRST_NAME, LAST_NAME FROM CUSTOMER
ORDER BY FIRST_NAME ASC
LIMIT 10;

-- ALIASES
-- ==> USED TO CHANGE THE NAME OF A COLUMN, TABLE 
-- AS ==> USED TO ALIAS 

SELECT FIRST_NAME AS F, LAST_NAME SURNAME FROM CUSTOMER;

-- AGGREGATE FUNCTIONS
-- ==> PERFORMS SIMPLE STATISTICAL OPERATIONS
-- ==> WORK ON ONLY ONE COLUMN AT A TIME, EXCEPT USED WITH A GROUP BY OR WITH OTHER AGGREGATE FUNCTIONS
-- ==> CHANGES THE NAME OF THE COLUMN 
-- ==> THE COLUMN TO BE AGGREGATED IS USUALLY IN BRACKETS()

-- MIN
-- GIVES THE MINIMUM VALUES IN A COLUMN
SELECT AMOUNT FROM PAYMENT;

SELECT MIN(AMOUNT) FROM PAYMENT;

-- MAX
-- RETURNS THE MAXIMUM VALUE IN A COLUMN 
SELECT MAX(AMOUNT) FROM PAYMENT;

-- SUM
-- GIVES US THE TOTAL SUM OF ALL THE ENTRIES IN THE COLUMN 
SELECT SUM (AMOUNT) FROM PAYMENT;

-- AVG
-- GIVES US THE AVERAGE MEAN OF THE ENTRIES IN THE COLUMN
SELECT AVG(AMOUNT) FROM PAYMENT;

-- COUNT 
-- FREQUENCY OF ENTRY 
-- COUNTS THE NUMBER OF ENTRIES 
-- IT USED ANSWER THE QUESTION OF 'HOW MANY'
-- WHEN USED WITH COUNT(*) ==> COUNTS ALL OF THE COLUMNS INCLUDING NULLS/BLANKS 
-- WHEN USED WITH COUNT(COLUMN_NAME) ==> IT DOES NOT COUNT THE NULL OR BLANK VALUES

SELECT COUNT(*) FROM PAYMENT;
SELECT COUNT(AMOUNT) FROM PAYMENT;

SELECT MIN(AMOUNT), MAX(AMOUNT), SUM(AMOUNT), COUNT(AMOUNT) FROM PAYMENT;

-- WE CAN ALIAS ALL THESE COLUMN NAMES
SELECT MIN(AMOUNT) AS LOWEST_SALES, MAX(AMOUNT) AS HIGHEST_SALES, SUM(AMOUNT) TOTAL_SALES, COUNT(AMOUNT) COUNT_OF_SALES FROM PAYMENT;

------------------------------------
-- DAY 03

-- GROUP BY
-- USED TO GROUP RECORDS IN A COLUMN 
-- USED WITH AGGREGATE FUNCTIONS TO PERFORM AGGREGATES ON THE GROUPED COLUMNS 

SELECT * FROM PAYMENT;
-- WE WANT TO KNOW THE TOTAL AMOUNT SPENT BY EACH CUSTOMER?
SELECT CUSTOMER_ID, AMOUNT FROM PAYMENT;

SELECT CUSTOMER_ID, SUM(AMOUNT) FROM PAYMENT
GROUP BY CUSTOMER_ID;

-- WE WANT TO KNOW HOW MANY TIMES EACH CUSTOMER PATRONIZED US ?
SELECT CUSTOMER_ID, COUNT(AMOUNT) FROM PAYMENT
GROUP BY CUSTOMER_ID;

-- WHO IS OUR MOST VALUABLE CUSTOMER?
-- CHISOM 
SELECT CUSTOMER_ID, MAX(AMOUNT) FROM PAYMENT 
GROUP BY CUSTOMER_ID;
-- WORNG, GIVES THE MAXIMUM AMOUNT BOUGHT BY EACH CUSTOMER 

-- BANJI
SELECT CUSTOMER_ID, SUM(AMOUNT) FROM PAYMENT 
GROUP BY CUSTOMER_ID
ORDER BY SUM(AMOUNT) DESC;

--- THIS GIVES THE TOTAL SUM BY EACH CSTOMER 

SELECT CUSTOMER_ID, SUM(AMOUNT) FROM PAYMENT 
GROUP BY CUSTOMER_ID
ORDER BY SUM(AMOUNT) DESC
LIMIT 1;

--- ISMAIL
SELECT CUSTOMER_ID, COUNT(AMOUNT) FROM PAYMENT 
GROUP BY CUSTOMER_ID
ORDER BY COUNT(AMOUNT) DESC

SELECT CUSTOMER_ID, SUM(AMOUNT), COUNT(AMOUNT) FROM PAYMENT 
GROUP BY CUSTOMER_ID
ORDER BY SUM(AMOUNT) DESC;


-- HAVING 
-- ==> USED TO FILTER GROUPED RECORDS 
-- IT CAN DO EVERYTHING A WHERE DOES 
-- IT IS ALWAYS AFTER THE GROUP BY 

-- HOW MUCH HAS EACH CUSTOMERS WHO SPENT ABOVE $200 SPENT EXACTLY ?
SELECT CUSTOMER_ID, SUM(AMOUNT) FROM PAYMENT 
GROUP BY CUSTOMER_ID
HAVING SUM(AMOUNT) >= 200;

-- We want to know the average rental rate of these 3 ratings: R,  PG, G.
-- Oluwasola 
select rating, avg(rental_rate) from film
group by rating 
having rating in ('R', 'PG', 'G');

---
-- JOINS 
-- THEY ARE USED TO MERGE TABLES TOGETHER 
-- THIS IS DONE WITH THE RELATIONSHIP KEYS (PRI-FOR)
-- -- HOW TO JOIN 
-- IDENTIFY THE TABLES TO JOIN
-- TAKE NOTE OF THE RELATIONSHIP KEYS
-- TAKE NOTE OF THE COLUMNS NEEDED AND THE TABLE EACH COLUMNS RESIDES
-- PUT ALL THE COLUMNS IN A SINGLE  SELECT STATEMENT 
-- ADD THE FIRST TABLE AFER THE FROM STATEMENT 
-- STATE THE JOIN TYPE 
-- ADD THE SECOND TABLE 
-- INTRODUCE THE JOINING CONDITION ==> ON , BASED ON THE RELATIOSHIPS 
-- TO PREVENT AMBIGOUS COLUMNS:
	-- WE ALIAS OUR TABLE NAMES
	-- WE USE TABLE.COLUMNAME SYNTAX ON THE AMBIGOUS COLUMNS, THIS IS SPECIFY THE TABLES THE COLUMNS ARE PRESENT IN



-- INNER
-- GIVES ONLY WHAT IS COMMON TO BOTH SIDES 
-- WE WANT TO KNWOW THE NAME OF THE CUSTOMERS THAT PATRONISES US 

SELECT * FROM CUSTOMER;
-- FIRST_NAME, LAST_NAME

SELECT * FROM PAYMENT;
-- CUSTOMER_ID, AMOUNT

-- RELATIONSHIP = CUSTOMER_ID  ==> COMMON TO BOTH SIDES

--JOINNING NOW:

SELECT FIRST_NAME, LAST_NAME, CUSTOMER_ID, AMOUNT  
FROM CUSTOMER INNER JOIN PAYMENT  
ON CUSTOMER_ID = CUSTOMER_ID 

SELECT FIRST_NAME, LAST_NAME, CUSTOMER_ID, AMOUNT  
FROM CUSTOMER  INNER JOIN PAYMENT
ON CUSTOMER.CUSTOMER_ID = PAYMENT.CUSTOMER_ID 

SELECT CUSTOMER.FIRST_NAME, CUSTOMER.LAST_NAME, PAYMENT.CUSTOMER_ID, PAYMENT.AMOUNT  
FROM CUSTOMER INNER JOIN PAYMENT  
ON CUSTOMER.CUSTOMER_ID = PAYMENT.CUSTOMER_ID 

SELECT C.FIRST_NAME, C.LAST_NAME, P.CUSTOMER_ID, P.AMOUNT  
FROM CUSTOMER C INNER JOIN PAYMENT P
ON C.CUSTOMER_ID = P.CUSTOMER_ID 


-- LEFT 
-- PRESERVES THE RECORD ON THE TABLE IN THE LEFT SIDE AND ONLY THE MATCHNG REORD OF THE RIGH SIDE IS SHOWN
-- THE UNMATCHING ROWS WOULD BE REPRESENTED BY NULL

-- we get the names of the all films and confirm if they Are in the Inventory table or not
SELECT * FROM FILM;
-- TITLE, FILM_ID
SELECT * FROM INVENTORY;
-- INVENTORY_ID, FILM_ID 

-- RELATIONSHP == FILM_ID
-- JOINING 

SELECT FILM.FILM_ID, FILM.TITLE, INVENTORY.INVENTORY_ID, INVENTORY.FILM_ID
FROM FILM LEFT JOIN INVENTORY 
ON FILM.FILM_ID = INVENTORY.FILM_ID ;


-- RIGHT
SELECT FILM.FILM_ID, FILM.TITLE, INVENTORY.INVENTORY_ID, INVENTORY.FILM_ID
FROM FILM RIGHT JOIN INVENTORY 
ON FILM.FILM_ID = INVENTORY.FILM_ID ;

-- REVERSES THE LEFT JOIN 
-- FULL 
-- ALL RECORDS ARE SHOWN
SELECT FILM.FILM_ID, FILM.TITLE, INVENTORY.INVENTORY_ID, INVENTORY.FILM_ID
FROM FILM FULL JOIN INVENTORY 
ON FILM.FILM_ID = INVENTORY.FILM_ID ;


-- DATA DEFINITION LANGUAGE

-- CREATING TABLES
-- 01: WE USE THE SYNTAX ==> CREATE TABLE TABLENAME ()
-- 02: WE ADD THE COLUMN NAMES WITHIN THE BRACKETS
-- 03: WE ADD THE DATATYPES TO EACH COLUMN
-- 04: WE SPECIFY RELATIONSHIP (PRIMARY, ETC)
-- 05: WE ADD CONSTRAINT (UNIQUE, NOT NULL, AUTOINCREMENT)
-- PRIMARY KEY ==> UNIQUE + NOT NULL
-- CREATE A TABLE FOR QUATUM ANALYTICS APRIL COHORT 

CREATE TABLE APRIL2022 (
	STUDENT_NO INT PRIMARY KEY,
	STUDENT_NAME VARCHAR NOT NULL,
	GENDER VARCHAR NOT NULL,
	LOCATION VARCHAR,
	EMAIL VARCHAR UNIQUE NOT NULL
)

-- INSERTING INTO TABLES 
-- ==> INSERT INTO TABLENAME 
-- PUT THE COLUMNS INTO THE BRACKET
-- THEN ==> VALUES 
-- THEN ADD EACH ENTRY 

INSERT INTO APRIL2022 (STUDENT_NO, STUDENT_NAME, GENDER, LOCATION, EMAIL)
VALUES 
	('1', 'OGUNDIPE', 'MALE', 'LAGOS', 'OG@QA.COM'),
	('2', 'CHISOM', 'FEMALE', 'ABUJA', 'CH@QA.COM');


SELECT * FROM APRIL2022;


-- DROPING 
-- ==> USED TO DELETE TABLES 
-- ==>DROP TABLE TABLENAME

DROP TABLE APRIL2022;

ALTER
UPDATE
CASE WHEN END

-- CASE-WHEN, SUBQUERRIES, CTE, VIEWS ETC 
-- PRACTICE  X10000
-- USE GOOGLE, YOUTUBE, W3SCHOOL, SQLSHACK 

--- TO CONNECT WITH ME 
-- ABDULLAH BANKOLE 
-- https://www.linkedin.com/in/abdullahbankole/

-- THANKS FOR CHOOSING QUANTUM ANALYTICS 