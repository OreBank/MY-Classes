-- MYSQL ARPIL DAFI COHORT 
-- DAY 2 
-- FACILITATED BY ABDULLAH BANKOLE
-- QUANTUM ANALYTICS 

-- SELECT STATEMENT
-- SELECT IS USED TO FETCH OR RETRIEVE ALL COLUMNS, MULTIPLE COLUMNS OR A SINGLE COLUMN FROM A TABLE 
-- ALL COLUMNS ==> *
SELECT * FROM employees; 

SELECT * FROM ORDERS;

-- SELECT MULTIPLE COLUMNS 
-- INPUT THE NAME OF THE DESIRED COLUMNS AFTER THE SELECT STATEMENT
SELECT LASTNAME, FIRSTNAME, EMAIL FROM EMPLOYEES;

-- SELECT SINGLE COLUMN 
-- INPUT THE NAME OF THE DESIRED COLUMN AFTER THE SELECT STATEMENT
SELECT EMAIL FROM EMPLOYEES;

-- REMOVING DUPLICATES 
--  DISTINCT ==> USED TO REMOVE DUPLICATE RECORDS 
SELECT * FROM PRODUCTS;
SELECT PRODUCTLINE FROM PRODUCTS;

SELECT DISTINCT productline FROM products;

-- GET THE DIFFERECT JOB TITLES OF EMPLOYEES IN THE COMPANY
SELECT * FROM EMPLOYEES;

SELECT DISTINCT JOBTITLE FROM EMPLOYEES;

-- CLASS WORK
-- We want to know the types of office codes for our employees
-- DARNELA
SELECT DISTINCT OFFICECODE FROM EMPLOYEES;

-- FILTERING RECORDS 
-- TO FILTER RECORDS, WHERE STATEMENT IS USED 
-- WE FILTER WITH OPERATORS AND PREDICATES
-- OPERATORS ==> =,>,<,!, AND, OR, ETC

-- GET THE INFO OF THE CUSTOMER(S) WHOSE CONTACTFIRSTNAME IS  JULIE
SELECT * FROM CUSTOMERS
WHERE CONTACTFIRSTNAME = 'JULIE';

-- GET THE INFO OF THE CUSTOMER(S) WHOSE CONTACTFIRSTNAME IS  JULIE AND LASTNAME IS KING
SELECT * FROM CUSTOMERS
WHERE CONTACTFIRSTNAME = 'JULIE' AND CONTACTLASTNAME = 'KING';

-- One of our customers, Baane Mini Imports, need to know who their contact person is. 
-- Use your SQL skills to get this person NAMES and their  city;
-- TOLU
SELECT * FROM CUSTOMERS 
WHERE CUSTOMERNAME = 'Baane Mini Imports';

-- DARNELA
SELECT CUSTOMERNAME, CONTACTFIRSTNAME, CONTACTLASTNAME, CITY FROM CUSTOMERS 
WHERE CUSTOMERNAME = 'Baane Mini Imports' ;

-- FILTERING WITH PREDICATES 
-- BETWEEN 
-- USED WHEN FILTERING WITHIN RANGE OF VALUES 
-- USED TO REPLACE THE >= AND <= IN A STATEMENT 

-- GET THE CUSTOMERNUMBER, CHECKNUMBER AND AMOUNTS FOR PAYMENTS THAT ARE BETWEEN $8000 AND $9000
SELECT * FROM PAYMENTS;

SELECT CUSTOMERNUMBER, CHECKNUMBER, AMOUNT FROM PAYMENTS
WHERE AMOUNT BETWEEN 8000 AND 9000;

SELECT CUSTOMERNUMBER, CHECKNUMBER, AMOUNT FROM PAYMENTS
WHERE AMOUNT >= 8000 AND AMOUNT <= 9000;

-- NOT BETWEEN
-- NEGATION OF BETWEEN 
-- GET THE CUSTOMERNUMBER, CHECKNUMBER AND AMOUNTS FOR PAYMENTS THAT ARE NOT BETWEEN $8000 AND $9000
SELECT CUSTOMERNUMBER, CHECKNUMBER, AMOUNT FROM PAYMENTS
WHERE AMOUNT NOT BETWEEN 8000 AND 9000;


-- IN 
-- You use the IN statement with the WHERE clause to check if the value(s) matches any value in the records
-- it is used to replace multiple = signs
-- the values are enclosed in brackets ()

-- Suppose I want to know find the offices located in the USA and France
select * from offices
where country in ('usa', 'france');

select * from offices
where country = 'usa' and country = 'france';

-- NOT IN 
-- NEGATION OF IN 
-- Suppose I want to know find the offices that are not located in the USA and France
select * from offices
where country NOT in ('usa', 'france');

-- LIKE 
-- USED FFOR PATTERN FILTERING 
-- WORKS WITH TWO SIGNS
-- % ==> WILDCARD 
-- 	ALLOWS US TO FILTER WITH AS MANY AS POSSIBLE CHARACTERS
-- _ ==> UNDERSCORE 
-- ALLOWS US TO FILTER WITH A CHARACTER AT A TIME

-- GET THE FULL CONTACT NAMES OF CUSTOMERS WTH FIRST NAME STARTING WITH 'Je'
SELECT CONTACTFIRSTNAME, CONTACTLASTNAME  FROM CUSTOMERS
WHERE CONTACTFIRSTNAME LIKE 'Je%';

-- CUSTOMERS WTH lastname  ending WITH 'on'
SELECT CONTACTFIRSTNAME, CONTACTLASTNAME  FROM CUSTOMERS
WHERE CONTACTLASTNAME LIKE '%on' ;

-- CUSTOMERS WTH lastname  ending WITH 'on' and firstname is susan 
SELECT CONTACTFIRSTNAME, CONTACTLASTNAME  FROM CUSTOMERS
WHERE CONTACTLASTNAME LIKE '%on' and contactfirstname = 'susan';


-- To find employees whose FIRST names start with the letter j , end with the letter N AND WE KNOW THAT IT IS A 4 LETTERS NAME
SELECT * FROM CUSTOMERS
WHERE CONTACTFIRSTNAME LIKE 'J__N';

SELECT * FROM CUSTOMERS
WHERE CONTACTFIRSTNAME LIKE 'J%N';

SELECT * FROM CUSTOMERS
WHERE CONTACTFIRSTNAME LIKE 'S___N';

-- SORTING RECORDS 
-- ==> ORDER BY 
-- SORT BY ASCENDING OR DESCENDING 
-- ASCENDING ==> LOWEST TO HIGHEST (1-100), (A-Z) 
-- 	==> ASC
-- DESCENDING ==> HIGHEST TO LOWEST (100-1), (Z-A)
-- 	==> DESC 

SELECT CONTACTFIRSTNAME, CONTACTLASTNAME  FROM CUSTOMERS
ORDER BY CONTACTFIRSTNAME ASC;

SELECT * FROM PAYMENTS
ORDER BY AMOUNT DESC;

-- LIMITING RECORDS 
-- LIMIT IS USED 
SELECT * FROM PAYMENTS
ORDER BY AMOUNT DESC
LIMIT 5;

SELECT CONTACTFIRSTNAME, CONTACTLASTNAME  FROM CUSTOMERS
ORDER BY CONTACTFIRSTNAME ASC
LIMIT 10;

-- AGGREGATING RECORDS 
-- THE AGGREGATE FUNCTIONS ARE USED TO PERFORM SIMPLE STATISTICAL OPERATIONS
-- THEY ARE ALWAYS IN THE SELECT STATEMENT 
-- THE COLUMN HTYE ARE WORKING ARE IN BRACKETS 

-- MIN 
-- USED THE RETRIEVE THE MINIMUM VALUE IN A COLUMN 
SELECT MIN(AMOUNT) FROM PAYMENTS ;

-- MAX
-- USED TO RETRIEVE THE MAXIMUM VALUE IN A COLUMN
SELECT MAX(AMOUNT) FROM PAYMENTS;

-- SUM 
-- GIVES A TOTAL OF ALL THE VALUES IN A COLUMN
SELECT SUM(AMOUNT) FROM PAYMENTS;

-- AVG 
-- GIVES THE AVERAGE MEANS OF THE VALUES IN A COLUMN
SELECT AVG(AMOUNT) FROM PAYMENTS;

-- COUNT 
-- GIVES THE FREQUENCY OF THE COLUMN
-- USED TO RESPOND TO THE QUESTION OF 'HOW MANY'
SELECT COUNT(AMOUNT) FROM PAYMENTS;

-- ALIASES 
-- RENAMING A COLUMN OR TABLE NAME 
-- AS ==> IS USED 

SELECT COUNT(AMOUNT) AS TRANSACT_FREQ FROM PAYMENTS;

SELECT SUM(AMOUNT) TOTAL_AMOUNT FROM PAYMENTS;

SELECT SUM(AMOUNT) FROM PAYMENTS AS P;

-- ASSIGNMENT 
-- 01 I want to see the contactfirst name of customers that has A 'her' as the second alphabets
-- 02 We want to send out a promotional message to our  existing customers. 
-- We would need their phone numbers, first  name and last name.
-- 03 Can you get me the phone number for the person who lives at '67, rue des Cinquante Otages'
-- 04 Get the Customer ID numbers for the top 10 highest amounts

-- DAY 03 

-- GROUPING RECORDS 
-- GROUP BY ==> USED TO GROUP RECORDS WITHIN A COLUMN
-- THEY WORK WITH AGGREGATE FUNCTIONS 

SELECT * FROM PAYMENTS;

SELECT CUSTOMERNUMBER, AMOUNT FROM PAYMENTS
GROUP BY CUSTOMERNUMBER;

-- GET THE AMOUNT OF TIMES EACH CUSTOMER PATRONIZE US 
SELECT CUSTOMERNUMBER, COUNT(AMOUNT) AS FREQ FROM PAYMENTS
GROUP BY CUSTOMERNUMBER; 

-- GET THE TOTAL AMOUNT SPENT BY EACH CUSTOMER 
SELECT CUSTOMERNUMBER, SUM(AMOUNT) AS TOTAL_AMOUNT FROM PAYMENTS
GROUP BY CUSTOMERNUMBER
ORDER BY SUM(AMOUNT) DESC;

-- FILTERING GROUPED RECORDS
-- HAVING ==> IS USED TO FILTER GROUPED RECORDS
-- IT WORKS JUST LIKE 'WHERE'
-- WHERE ==> UNGROUPED RECORDS, BEFORE GROUP BY SYNTAX
-- HAVING ==> GROUPED RECORDS, AFTER THE GROUP BY SYNTAX 
-- IT CAN DO EVERYTHING ==> >,<, IN, BETWEEN, AND etc. 

-- We want to know the average payment amount of these 3 customers: 103, 146, 172
 SELECT CUSTOMERNUMBER, AVG(AMOUNT) AVG_PAYMENT FROM PAYMENTS
 GROUP BY CUSTOMERNUMBER
 HAVING CUSTOMERNUMBER = 103 OR CUSTOMERNUMBER = 146 OR CUSTOMERNUMBER = 172;
 
SELECT CUSTOMERNUMBER, AVG(AMOUNT) AVG_PAYMENT FROM PAYMENTS
GROUP BY CUSTOMERNUMBER
HAVING CUSTOMERNUMBER IN (103, 146, 172);
 
-- JOINS 
-- USED TO MERGE TWO OR MORE TABLES TOGETHER 
-- TYPES ==> INNER, LEFT, RIGHT, FULL

-- TIPS OF HOW TO PERFORM A JOIN 
-- 01 - IDENTIFY THE COLUMNS FROM THE TABLES YOU ARE JOINING
-- 02 - SPECIFY THE FIRST TABLE 
-- 03 - SPECIFY THE JOIN TYPE 
-- 04 - ADD THE THE SECOND TABLE 
-- 05 - SPECIFY THE JOINING CONDITION WITH SYNTAX "ON" 
-- ON ==> ON RELATIONSHIP IN TABLE A = RELATIONSHIP IN TABLE B
-- 06 - TO PREVENT AMBIGUITY, WE USE THE TABLE.COLUMNNAME NAMING SYNTAX
-- TABLE.COLUMNNAMES ==> PAYMENTS.AMOUNT 
-- WE MIGHT ALIAS THE TABLESNAME, PAYMENTS P, P.AMOUNT 

-- INNER
-- FETCH THE NAME OF THE CUSTOMERS THAT HAVE PATRONIZED THE COMPANY 
SELECT * FROM PAYMENTS;
-- CUSTOMERNUMBER, AMOUNT 

SELECT * FROM CUSTOMERS;
-- CUSTOMERNAME, CUSTOMERNUMBER 

-- RELATIONSHIP ==> CUSTOMERNUMBER
-- JOINING 
SELECT CUSTOMERNAME, CUSTOMERNUMBER, CUSTOMERNUMBER, AMOUNT 
FROM CUSTOMERS INNER JOIN PAYMENTS
ON CUSTOMERNUMBER = CUSTOMERNUMBER;
-- THIS GIVES AN ERROR


-- PREVENTING AMBIGUITY ( USE TABLE.COLUMNNAME FOR THE AMBIGOUS COLUMNS)
SELECT CUSTOMERNAME, CUSTOMERS.CUSTOMERNUMBER, PAYMENTS.CUSTOMERNUMBER, AMOUNT 
FROM CUSTOMERS INNER JOIN PAYMENTS
ON CUSTOMERS.CUSTOMERNUMBER = PAYMENTS.CUSTOMERNUMBER;

-- WITH ALIASES 
SELECT CUSTOMERNAME, C.CUSTOMERNUMBER, P.CUSTOMERNUMBER, AMOUNT 
FROM CUSTOMERS C INNER JOIN PAYMENTS AS P
ON C.CUSTOMERNUMBER = P.CUSTOMERNUMBER;

-- LEFT 
-- fetch all customernames with their orders, whether they have taken an order or not 

SELECT CUSTOMERNAME, C.CUSTOMERNUMBER, P.CUSTOMERNUMBER, AMOUNT 
FROM CUSTOMERS C LEFT JOIN PAYMENTS AS P
ON C.CUSTOMERNUMBER = P.CUSTOMERNUMBER;

SELECT CUSTOMERNAME, C.CUSTOMERNUMBER, P.CUSTOMERNUMBER, COUNT(AMOUNT)
FROM CUSTOMERS C LEFT JOIN PAYMENTS AS P
ON C.CUSTOMERNUMBER = P.CUSTOMERNUMBER
GROUP BY CUSTOMERNAME, C.CUSTOMERNUMBER, P.CUSTOMERNUMBER
ORDER BY 4 DESC ;
 
-- UNION
-- USED TO MERGE TWO OR MORE SELECT STATEMENT TOGETHER 
-- RULES:
-- BOTH STATMENTS MUST RETURN THE SAME NUMBER OF COLUMNS 
-- THE CORRESPONDING COLUMNS IN THE QUERRIES MUST HAVE THE SAME DATATYPE 

-- TYPES: UNION, UNION ALL 
-- UNION ==> USED WHEN WE DONT WANT DUPLICATE RECORDS 
-- UNION ALL ==> WHEN WE WANT DUPLICATE RECORDS

-- GET THE NAMES FIRST AND LASTNAMES OF EVERYONE CONCERNED (EMPLOYEES AND CUSTOMERS) WITH THE COMPANY

SELECT * FROM EMPLOYEES;
-- LASTNAME, FIRSTNAME 

SELECT * FROM CUSTOMERS;
-- CONTACTLASTNAME, CONTACTFIRSTNAME 

-- USING UNION
SELECT LASTNAME, FIRSTNAME FROM EMPLOYEES 
UNION 
SELECT CONTACTLASTNAME, CONTACTFIRSTNAME FROM CUSTOMERS ;

SELECT LASTNAME, FIRSTNAME FROM EMPLOYEES 
UNION ALL
SELECT CONTACTLASTNAME, CONTACTFIRSTNAME FROM CUSTOMERS ;

-- DATA DEFINITION LANGUAGE 
-- THEY ARE USED TO DEFINE THE OBJECTS(TABLES, SCHEMAS, DATABASE) IN A DATABASE

-- CREATING TABLES/ SCHEMA/ DATABASE 
-- TO CREATE, WE USE THE "CREATE OBJECT" SYNTAX
-- CREATING TABLE 
-- STEPS 
-- 01 - USE THE SYNTAX ==> CREATE TABLE 
-- 02 - PUT THE TABLENAME AFTER CREATE TABLE 
-- 03 - OPEN A BRACKET 
-- 04 - WITHIN THE BRACKET, YOU ADD THE COLUMNS YOU WANT IN THE TABLE 
-- 05 - ADD THE DATATYPE FOR EACH COLUMN 
-- 06 - ADD THE CONSTRAINTS

-- DATATPYES ==> THE TYPE OF VALUE OR DATA YOU WANT IN THE COLUMN 
-- NUMBERS ==> INT ==> WHOLE NUMBERS - 1,2,3 , FLOATS ==> DECIMAL NUMBERS 1.2, 2.7,4.89
-- CHARACTERS ==> CHAR (FIXED LENGHT STRINGS), VARCHAR (VARIABLE LENGTH) ==> letters, numbers, special characters
-- DATE ==> DATE (YYYY-MM-DD), DATETIME (YYYY-MM-DD hh:mm:ss), TIMESTAMP

-- CONSTRAINTS ==> used to specify column rules 
-- unique ==> ensures that all values are different 
-- not null ==> ensure that the column does not accept null values 
-- primary key ==> unique + not null 

-- lets create a table for the april cohort
-- STUDENT NO ==> DAFI + FIRSTLETTER OF FIRSTNAME + FIRSTLETTER OF LASTNAME + NUMBER ==> DAFIMB001
CREATE TABLE DAF_APRIL_COHORT (
STUDENT_NO CHAR(9) PRIMARY KEY,
STUDENTNAME VARCHAR(50) NOT NULL,
SEX CHAR(2) NOT NULL,
LOCATION VARCHAR(20) ,
PHONE_NO VARCHAR(11) UNIQUE ,
PROFESSION VARCHAR(20) 
);

-- INSERTING RECORDS INTO TABLES 
-- ==> USE THE 'INSERT INTO' SYNTAX
-- ==> ADD THE TABLE WE WANT TO INSERT RECORD INTO 
-- ==> OPEN A BRACKET 
-- ==> WITHIN THE BRACKET ADD ALL THE COLUMNS WE WANT TO INSERT RECORDS INTO 
-- ==> ADD THE KEYWORD 'VALUES'
-- ==> OPEN ANOTHER BRACKET 
-- ==> WITHIN THE BRACKET, ADD THE VALUES TO THE CORRESPONDING COLUMNS 

-- LETS INSERT INTO THE DAF_APRIL_COHORT TABLE 
INSERT INTO DAF_APRIL_COHORT
(STUDENT_NO, STUDENTNAME, SEX, LOCATION, PHONE_NO, PROFESSION)
VALUES 
('DAFIKA001', 'KUNLE ALADEOBA', 'NB', 'LAGOS', '08033314769', 'PUBLIC SERVANT'),
('DAFIGA002', 'GLORIA ALADESULU', 'FE', 'USA', '8322138460', 'FINANCIAL ANALYST'),
('DAFIRN003', 'RITA NWOKEJI', 'FE', 'UK', '07713011585', 'ACCOUNTANT'),
('DAFIDM004', 'DARNELA MBOUMBA', 'FE', 'SWEDEN', '07205906894', 'SHIPSMASTER'),
('DAFITA005', 'TOLU ABORISHADE', 'FE', 'IBADAN', '08033108979', 'CIVIL SERVANT');

SELECT * FROM DAF_APRIL_COHORT;

-- DELETING OBJECTS 
-- TO DELETE OBJECTS, WE USE THE ==> DROP OBJECT SYNTAX
-- SPECIFY THE NAME OF THE OBJECT AFTER THE SYNTAX 

-- DELETING TABLES
DROP TABLE DAF_APRIL_COHORT;

-- UPDATING RECORDS IN A TABLE.
-- WE USE THE UPDATE TABLENAME SYNTAX
-- THEN WE USE 'SET COLUMN = NEW_UPDATE'
-- THEN WE USE WHERE TO FILTER

-- LETS CHANGE IBADAN TO USA FOR TOLU ABORISHADE
UPDATE DAF_APRIL_COHORT
SET LOCATION = 'USA'
WHERE STUDENT_NO = 'DAFITA005';

SELECT * FROM DAF_APRIL_COHORT;

-- USE GOOGLE, YOUTUBE, W3SCHOOLS, SQLSHACK

-- FIND ME ON LINKEDIN 
-- ABDULLAH BANKOLE 
-- LINKEDIN = www.linkedin.com/in/abdullahbankole/














