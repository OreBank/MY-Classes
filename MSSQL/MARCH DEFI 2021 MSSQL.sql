-- MARCH DEFI 2021 COHORT
-- FACILITATED BY ABDULLAH BANKOLE
-- DATA ANALYST, QUANTUM ANALYTICS

-- SCHEMAS 
-- ==> HUMANRESOURCES, PERSON, PRODUCTION, PURCHASING, SALES.


-- SELECT 
-- USED TO FETCH ALL THE COLUMNS, SPECIFIC/MULTIPLE COLUMNS OR A SINGLE COLUMN FROM A TABLE WITHIN THE DB

-- ALL THE COLUMNS 
-- (*)

SELECT * FROM Person.Person;

SELECT * FROM Production.Product;

SELECT * FROM HumanResources.Employee;

-- SELECT SPECIFIC COLUMNS 
-- WE JUST CALL THE COLUMN NAMES AFTER THE SELECT STATEMENT
select BusinessEntityID, LoginID, OrganizationLevel, JobTitle from HumanResources.Employee;

select ProductID, Name, Color, ListPrice from Production.Product;

-- A SINGLE COLUMN

SELECT NAME FROM Production.Product;

SELECT JOBTITLE FROM HumanResources.Employee;

-- ALIASES 
-- USED TO RENAME COLUMNS, TABLES 
-- WE USE 'AS' TO ALIAS OR WE USE SPACE BETWEEN THE FORMER NAME AND THE NEW NAME 

SELECT * FROM Person.Person;
SELECT FirstName, LastName FROM Person.Person

SELECT FIRSTNAME AS FNAME, LASTNAME AS LNAME FROM Person.Person;

SELECT FIRSTNAME FNAME, LASTNAME SURNAME FROM PERSON.Person;

--  Write a SELECT statement that lists the customer ID numbers and sales order 
SELECT * FROM [Sales].[SalesOrderHeader];

SELECT CUSTOMERID, SALESORDERNUMBER FROM SALES.SalesOrderHeader;

-- REMOVING DUPLICATES
-- DISTINCT ==> USED TO REMOVE DUPICATE RECORDS

SELECT COLOR FROM Production.Product;

SELECT DISTINCT COLOR FROM Production.Product;

SELECT * FROM Production.Product;


-- SORTING RECORDS
-- WE CAN SORT RECORDS IN EITHER ASCENDING OR DESCENDING ORDERS
-- ORDER BY ==> USED TO SORT RECORDS
-- ASC ==> ASCENDING 
-- DESC ==> DESCENDING


SELECT FIRSTNAME, LASTNAME FROM Person.Person
ORDER BY FIRSTNAME ASC;

SELECT FIRSTNAME, LASTNAME FROM Person.Person
ORDER BY LASTNAME DESC;

SELECT * FROM SALES.SalesOrderDetail;

SELECT LINETOTAL FROM SALES.SALESORDERDETAIL
ORDER BY LINETOTAL DESC;


SELECT * FROM SALES.SALESORDERDETAIL
ORDER BY LINETOTAL DESC;

-- LIMITING RECORDS 
-- IN MYSQL WE USE 'LIMIT' TO LIMIT THE RECORDS 
-- BUT IN MSSQL, WE USE 'TOP N'
SELECT * FROM SALES.SalesOrderDetail


SELECT TOP 20 * FROM SALES.SalesOrderDetail;

SELECT FIRSTNAME, LASTNAME FROM PERSON.Person;

SELECT TOP 50 FIRSTNAME, LASTNAME FROM PERSON.Person
ORDER BY LastName DESC;

-- FILTERING RECORDS
-- WHERE ==> MOTHER OF ALL FILTERS, USED TO FILTER RECORDS 
-- OPERATORS ==> =,>,<,>=,<=, != 

-- GET INFO ABOUT CUSTOMER 11000
SELECT * FROM SALES.SalesOrderHeader
WHERE CustomerID = 11000;

-- GET INFO OF PRODUCTS WITH PRICES GREATER THAN 1000
SELECT * FROM Production.Product
WHERE ListPrice > 1000;

-- GET INFO OF CUSTOMERS WITH LASTNAME ZHOU
SELECT * FROM Person.Person
WHERE LASTNAME = 'ZHOU';

-- GET ALL THE ORDERS FOR JULY 5, 2011 ==> YYYY-MM-DD
-- JULY 5, 2011 ==> 2011-06-05

SELECT * FROM Sales.SalesOrderHeader
WHERE ORDERDATE = '2011-06-05';

-- LOGICAL OPERATORS ==> AND, OR
-- AND ==> BOTH CONDITIONS TO BE TRUE
-- OR  ==> AT LEAST ONE OF THE CONDITIONS TO BE TRUE 

-- GET INFO OF PERSON WITH NAME KEN MYER

SELECT * FROM Person.Person
WHERE FirstName = 'Ken' and LastName = 'Myer';

SELECT * FROM Person.Person
WHERE FirstName = 'Ken' or LastName = 'Myer';

-- The sales orders with prices between 1000 and 2000
select * from sales.SalesOrderDetail
where LineTotal >= 1000 and LineTotal <= 2000;

-- PREDICATES ==> BETWEEN, IN, LIKE 

-- BETWEEN 
-- USED WHEN WE HAVE RANGE OF VALUES 
-- USED TO REPLACE THE ">= AND <="

-- The sales orders with prices between 1000 and 2000
select * from sales.SalesOrderDetail
where LineTotal >= 1000 and LineTotal <= 2000;

SELECT * FROM SALES.SalesOrderDetail
WHERE LINETOTAL BETWEEN 1000 AND 2000;

-- GET DETAILS OF SALES DONE IN THE MONTH OF August 2011
select * from sales.SalesOrderHeader;
-- for august 2011 ==> 2011-08-01 and 2011-08-31

SELECT * FROM SALES.SalesOrderHeader
WHERE ORDERDATE BETWEEN '2011-08-01' and '2011-08-31';

-- NOT BETWEEN 
-- THIS IS A NEGATION OF BETWEEN 
SELECT * FROM SALES.SalesOrderDetail
WHERE LINETOTAL NOT BETWEEN 1000 AND 2000;


-- IN
-- IN STATEMMENT IS USED TO REPLACE THE USE OF MULTIPLE "="
-- GET THE NAMES OF PRODUCTS THAT ARE BLUE, RED AND BLACK
SELECT NAME, COLOR FROM Production.Product
WHERE COLOR = 'BLUE' OR COLOR = 'RED' OR COLOR = 'BLACK'
ORDER BY COLOR;

SELECT NAME, COLOR FROM Production.Product
WHERE COLOR IN ('BLUE', 'RED', 'BLACK')
ORDER BY Color;


-- NOT IN 
-- A NEGATION OF IN 

SELECT NAME, COLOR FROM Production.Product
WHERE COLOR NOT IN ('BLUE', 'RED', 'BLACK')
ORDER BY Color;

-- LIKE 
-- USED FOR PATTERN MATCHING
-- The LIKE operator is used in a WHERE clause to search for a specified pattern in a column. 
-- IT HAS IT OWN SYMBOLS ==> "%" AND "_"
-- % => A WILDCARD,
--  => USED WHEN WE ARE NOT SURE OF THE NUMBER OF CHARACTERS /AS MANY CHARACTERS AS POSSIBLE 
--_ => WHEN WE ARE SURE, ONE _ MEANS ONE CHARACTER

-- GET THE NAMES OF PEOPLE HAVING 'SAND' BEGINNING THEIR LAST NAMES
SELECT FIRSTNAME, LASTNAME FROM PERSON.Person
WHERE LASTNAME LIKE 'SAND%';

SELECT FIRSTNAME, LASTNAME FROM PERSON.Person
WHERE LASTNAME LIKE 'SAND_';


-- FIND INFO OF PRODUCTS WITH 'DERAILLEUR'

SELECT * FROM Production.Product
WHERE NAME LIKE '%DERAILLEUR%';

-- WORKING WITH NULLS 
SELECT COLOR FROM Production.Product;
-- SEARCH FOR NULLS 
-- IS NULL ==> USED TO FILTER SEARCH NULLS
SELECT NAME, COLOR FROM Production.Product
WHERE COLOR IS NULL;

-- REPLACE NULL VALUES
-- ISNULL ==> USED TO REPLACE NULL VALUES 
-- ISNULL TAKES TWO ARGUMENTS (COLUMN WITH NULL, REPLACEMENT TEXT/VALUE)
-- ISNULL IS ALWAYS IN THE SELECT STATEMENT 

SELECT NAME, ISNULL(COLOR, 'NO COLOR') COLOR FROM Production.Product
WHERE COLOR IS NULL;

-- REMOVES NULL VALUES
SELECT COLOR FROM Production.Product
WHERE COLOR IS NOT NULL;

-- COALESCE, NULLIF ===> READ UP!

-- AGGREGATE STATEMENTS
-- USED TO PERFROM SIMPE STATISTICAL OPERATIONS IN SQL 
-- THEY ARE ALWAYS IN THE SELECT STATEMENT 
-- THEY CHANGE THE COLUMN NAMES
-- THE AGGREGATED COLUMNS MUST BE WITHIN A BRACKETS ()
-- THEY USUALLY STAND ALONE UNLESS USED WITH OTHER AGGREGATE FUNCTIONS OR WITH GROUP BY STATEMENTS

-- MIN
-- RETURNS THE MINIMUM VALUES IN A COLUMN 

SELECT LINETOTAL FROM Sales.SalesOrderDetail;

SELECT MIN(LINETOTAL) AS MIN_VALUE  FROM Sales.SalesOrderDetail;
-- MAX
-- RETURNS THE MAXIMUM VALUE IN A COLUMN
SELECT MAX(LINETOTAL) MAX_VALUE FROM Sales.SalesOrderDetail

-- AVG
-- RETURNS THE AVERAGE MEAN OF THE VALUES IN A COLUMN

SELECT AVG(LINETOTAL) AVG_VALUE FROM Sales.SalesOrderDetail

-- SUM
-- RETURNS THE SUM TOTAL OF THE VALUES IN A COLUMN
SELECT SUM(LINETOTAL) TOTAL_VALUE FROM Sales.SalesOrderDetail


-- COUNT
-- COUNT THE ROWS OR GIVES US FREQUENCY 
SELECT COUNT(LINETOTAL) COUNT_LINETOTAL FROM Sales.SalesOrderDetail

-- VAR
-- RETURNS THE VARIANCE OF THE VALUES IN A COLUMN
SELECT VAR(LINETOTAL) VAR_VALUE FROM Sales.SalesOrderDetail

-- STDEV
-- RETURNS THE STANDARD DEVIATION OF THE VALUES IN A COLUMN
SELECT STDEV(LINETOTAL) STDEV_VALUE FROM Sales.SalesOrderDetail


SELECT MIN(LINETOTAL) MIN_VALUE, MAX(LINETOTAL) MAX_VALUE, COUNT(LINETOTAL) COUNT_TOTAL, SUM(LINETOTAL) TOTAL_SALES
FROM Sales.SalesOrderDetail;


SELECT COUNT(ProductID), VAR(LINETOTAL) VAR_VALUE FROM Sales.SalesOrderDetail


-- GROUP BY 
-- ==> USED TO GROUP RECORDS 
-- ==> USUALLY USED WITH AGGREGATE FUNCTIONS 

SELECT * FROM SALES.SalesOrderDetail;

-- WHAT IS THE WORTH OF EACH SALESORDER 
SELECT SALESORDERID,LINETOTAL FROM Sales.SalesOrderDetail;

SELECT SALESORDERID, SUM(LINETOTAL) TOTAL FROM SALES.SalesOrderDetail
GROUP BY SalesOrderID;
--------------------------------------------------------------------
-- DAY O3

-- CLASS WORK
-- Write a query using the Production.Product table that lists a count of the 
-- products in each product line.

SELECT * FROM Production.Product;

SELECT DISTINCT PRODUCTLINE FROM Production.Product;

-- DEOLA & ADEBOLA
SELECT NAME,COUNT(PRODUCTLINE) FROM Production.Product
GROUP BY NAME;

-- CORRECT
SELECT PRODUCTLINE, COUNT(*) NO_OF_PRODUCTS FROM Production.Product
GROUP BY ProductLine;

-- ASSIGNMENT(1)
-- Write a query that displays the count of orders placed by year for each 
-- customer using the Sales.SalesOrderHeader table

-- DEOLA
SELECT ORDERDATE, COUNT(CUSTOMERID) ORDER_PER_YEAR FROM Sales.SalesOrderHeader
GROUP BY OrderDate;
-- 




--------------------------------------------------------------------
-- HAVING 
-- ==> USED TO FILTER GROUPED RECORDS 
-- ==> IT CAN DO EVERYTHING A WHERE DOES
-- ==> WORKS WITH BOTH PRECICATES AND OPERATORS

-- WE WANT TO KNOW THE PRODUCTS WHICH TOTAL SALES IS GREATER THAN 10000 
-- AND AMOUNT OF PRODUCT SOLD

SELECT * FROM Sales.SalesOrderDetail;

SELECT PRODUCTID, SUM(LINETOTAL) TOTAL_SALES, COUNT(ProductID) AMT_OF_PRODUCT
FROM SaleS.SalesOrderDetail
GROUP BY PRODUCTID
HAVING SUM(LINETOTAL) > 10000
ORDER BY 2;

-- Write a query that groups the products by ProductModelID along 
-- with a count. Display the rows that have a count that equals 1.
SELECT * FROM Production.Product;

SELECT ProductModelID, COUNT(*) CountOfProduct FROM Production.Product
GROUP BY ProductModelID
HAVING COUNT(*) = 1;


-- JOINS 
-- ==>JOINS ARE USED TO MERGE TWO OR MORE TABLES TOGETHER 
-- ==>THEY MUST SATISFY A MATCHING CRITERIA
-- ==>IT IS BASED ON PRIMARY-FOREIGN KEY RELATONSHIP

-- HOW TO JOIN
-- IDENTIFY THE TABLES WE ARE JOINING 
-- TAKE NOTE OF THE RELATIONSHIP KEYS (PRIMARY & FOREIGN KEYS)
-- TAKE NOTE OF THE COLUMNS NEEDED AND THE TABLE THE COLUMNS APPEAR 
-- MERGE THE COLUMNS TOGETHER IN THE SELECT STATEMENT
-- STATE THE JOIN TYPE AFTER THE FROM KEYWORD
-- ADD THE SECOND TABLE 
-- INTRODUCE THE JOINING CONDITION = (ON) WITH RELATIONSHIP
-- TO AVOID AMBIGOUS COLUMN:
	-- WE CAN ALIAS OUR TABLES NAMES 
	-- WE USE THE TABLE.COLUMNNAME FOR THE AMBIGOUS COLUMN



-- INNER JOIN
--GET THE NAMES OF THE EMPLOYEES IN THE COMPANY

SELECT * FROM HumanResources.Employee;
-- JOBTITLE,HIREDATE

SELECT * FROM PERSON.Person;
-- FIRSTNAME, LASTNAME

-- BUSINESSENTITYID IS COMMON TO BOTH SIDES (RELATIONSHIP)

SELECT FIRSTNAME, LASTNAME, JOBTITLE, HIREDATE
FROM HumanResources.Employee AS HRE INNER JOIN Person.Person PP
ON HRE.BusinessEntityID = PP.BusinessEntityID
ORDER BY HireDate;

SELECT HRE.BusinessEntityID, FIRSTNAME, LASTNAME, JOBTITLE, HIREDATE,  PP.BusinessEntityID
FROM HumanResources.Employee AS HRE INNER JOIN Person.Person PP
ON HRE.BusinessEntityID = PP.BusinessEntityID
ORDER BY HRE.BusinessEntityID;


-- OUTER JOIN
-- LEFT OUTER JOIN
-- ==> GET ALL THE CUSTOMERS INFO WHETHER THEY HAVE ORDERED OR NOT 
SELECT * FROM Sales.Customer;
-- CUSTOMERID

SELECT * FROM Sales.SalesOrderHeader;
-- SALESORDERID, ORDERDATE

SELECT SC.CUSTOMERID, SALESORDERID, ORDERDATE
FROM SALES.Customer SC LEFT JOIN SALES.SalesOrderHeader SOH
ON SC.CustomerID = SOH.CustomerID;

SELECT SC.CUSTOMERID, SALESORDERID, ORDERDATE, SOH.CustomerID
FROM SALES.Customer SC LEFT JOIN SALES.SalesOrderHeader SOH
ON SC.CustomerID = SOH.CustomerID
WHERE SOH.CustomerID IS NULL ;



-- RIGHT OUTER JOIN
-- FULL OUTER JOIN

SELECT SC.CUSTOMERID, SALESORDERID, ORDERDATE
FROM SALES.Customer SC FULL JOIN SALES.SalesOrderHeader SOH
ON SC.CustomerID = SOH.CustomerID;

-- SELF JOIN 
-- RARELY USED, INFACT IT IS ARCHAIC.... 


-- UNIONS 
-- ==> USED TO MERGE COLUMNS 
-- ==> USED TO COMNBINE TWO OR MORE SELECT STATEMENT
-- RULES
-- NO OF COLUMNS IN THE SELECT STATEMENT MUST BE THE SAME 
-- DATATYPES OF THE MERGING COLUMNS MUST BE THE SAME
-- THE ORDER OF THE COLUMNS MUST BE SAME 

--LETS MERGE RECORDS FROM HUMANRESOURCES.EMPLOYEE, PERSON.PERSON, SALESORDERHER
SELECT * FROM HumanResources.Employee;
SELECT * FROM PERSON.Person;
SELECT * FROM Sales.SalesOrderHeader

-- UNION ALL 
-- USED TO COMNBINE TWO OR MORE SELECT STATEMENTS WITH DUPLICATES
SELECT BusinessEntityID FROM HumanResources.Employee
UNION ALL
SELECT BusinessEntityID FROM PERSON.Person
UNION ALL
SELECT SalesOrderID FROM Sales.SalesOrderHeader

-- UNION

-- USED TO COMNBINE TWO OR MORE SELECT STATEMENTS WITHOUT DUPLICATES
SELECT BusinessEntityID FROM HumanResources.Employee
UNION 
SELECT BusinessEntityID FROM PERSON.Person
UNION 
SELECT SalesOrderID FROM Sales.SalesOrderHeader


-- DATA DEFINITION LANGUAGE 

-- CREATE
--==> USED TO CREATE OBJECT ( DATABASE, SCHEMA, TABLE)
 CREATE DATABASE QA_DAFI;

 CREATE SCHEMA US_COHORT;
 CREATE SCHEMA CANADA_COHORT;
-- HOW TO CREATE TABLES 
-- 01: WE USE THE SYNTAX = CREATE TABLE TABLENAME ()
-- 02: WE ADD THE COLUMN NAMES WITHIN THE BRACKETS
-- 03: WE ADD THE DATATYPES TO EACH COLUMN
-- 04: WE SPECIFY RELATIONSHIP (PRIMARY, ETC)
-- 05: WE ADD CONSTRAINT (UNIQUE, NOT NULL, IDENTITY)


 CREATE TABLE MARCH_COHORT_MSSQL(
 STUDENTID INT PRIMARY KEY IDENTITY(1,1),
 NAMES VARCHAR(20) NOT NULL,
 LOCATION VARCHAR(20)
 );
 SELECT * FROM MARCH_COHORT_MSSQL;
-- INSERT
--==> INSERT RECORDS INTO THE TABLE 
-- METHOD ONE

INSERT INTO MARCH_COHORT_MSSQL (NAMES, LOCATION)
VALUES 
	('ADEBOLA', 'CHINA'),
	('ADEOLA', 'NIGERIA'),
	('EZINNE', '' );

-- METHOD TWO 
 SELECT * FROM MARCH_COHORT_MSSQL;

-- DROP
-- ==> DELETE OBJECTS (DATABASE, SCHEMA, TABLES)
--DROP DATABASE QA_DAFI;
--DROP SCHEMA US_COHORT;
--DROP TABLE MARCH_COHORT_MSSQL;

-- ALTER
-- ==> USED TO ADD COLUMNS TO TABLES 
-- ==> USED TO DROP COLUMNS FROM TABLES
-- ==> USED TO MODIFY COLUMNS IN A TABLE (RENAME,CHANGE DATAYPE ETC)

-- ADD COLUMNS 
ALTER TABLE MARCH_COHORT_MSSQL
ADD COURSE VARCHAR(20);

-- DROP COLUMNS 
ALTER TABLE MARCH_COHORT_MSSQL
DROP COLUMN COURSE 


-- UPDATE 
-- ==> USED TO UPDATE RECORDS IN A TABLE 
UPDATE MARCH_COHORT_MSSQL
SET LOCATION = 'CANADA'
WHERE STUDENTID = 3;

-- 
SELECT * FROM CANADA_COHORT.TEST;

-------
-- MISCELLEANEUOS
-- VIEWS, SUBQUERRY
-- PRACTICE
-- LEARN ==> W3SCHOOL, YOUTUBE
-- CHALLENGES ==> GOOGLE,STACKOVERFLOW, STACKEXCAHNGE, YOUTUBE
-- DO YOUR ASSIGNMENT 

-- ABDULLAH BANKOLE
-- https://www.linkedin.com/in/abdullahbankole/
-- THANK YOU VERY MUCH