-- MSSQL MARCH COHORT DAY 02 
-- By ABDULLAH BANKOLE
-- FOR QUANTUM ANALYTICS


-- we use '--' to comment or to talk to ourselves
-- THE SCHEMAS IN THE DATABASE 
-- HUMAN RESOURCES
-- PERSON
-- Production
-- Purchasing
-- Sales

-- SYNTAXES
-- 01 SELECT FROM STATEMENT
-- used to fetch a column, MULTIPLES columns or all of the columns in a table.
-- SELECT COLUMN(S) FROM TABLE

-- SELECT ALL COLUMNS 
-- WE USE "*" AFTER SELECT STATEMENT TO SELECT ALL 

SELECT * FROM Person.Person;

SELECT * FROM Production.Product;

-- SELECT MULTIPLE
-- JUST PUT THE NAME OF THE COLUMNS AFER THE SELECT STATEMENT
SELECT PRODUCTID, NAME, PRODUCTNUMBER, COLOR FROM Production.Product;

-- SELECT A COLUMN

SELECT NAME FROM Production.Product;

-- ALIAS 
-- USED TO CHANGE THE COLUMN NAME OR TABLE NAMES 
-- TWO METHODS
-- METHOD 01 => (AS)
-- METHOD 02 => JUST PUT A SPACE BETWEEN THE OLD NAME AND THE NAME



SELECT * FROM Person.Person;

SELECT  BusinessEntityID, FirstName, LastName FROM Person.Person;

SELECT  BusinessEntityID AS PERSONID, FirstName, LastName FROM Person.Person;

SELECT  BusinessEntityID AS PERSONID, FirstName FNAME, LastName LNAME FROM Person.Person;

--  Write a SELECT statement that lists the customer ID numbers and sales order 
--  ID numbers from the Sales.SalesOrderHeader table
SELECT * FROM SALES.SalesOrderHeader;

SELECT CUSTOMERID, SalesOrderID FROM SALES.SalesOrderHeader;

-- REMOVING DUPLICATES
-- DISTINCT => USED TO REMOVE DUPLICATES

SELECT COLOR FROM Production.Product;

SELECT DISTINCT COLOR FROM Production.Product;

-- SORTING RECORDS  
-- TO SORT RECORDS WE USE => ORDER BY 

-- ASC => ASCENDING = LOWEST  TO HIGHEST 
-- DESC => DESCENDING = HIGHEST TO LOWEST 

SELECT FIRSTNAME, LASTNAME FROM Person.Person;

SELECT FIRSTNAME, LASTNAME FROM Person.Person
ORDER BY FIRSTNAME ASC;

SELECT FIRSTNAME, LASTNAME FROM Person.Person
ORDER BY LASTNAME DESC;

SELECT UnitPrice FROM SALES.SalesOrderDetail
ORDER BY UnitPrice DESC;

-- METHOD 2 
-- JUST KNOW THE POSITION OF THE COLUMN AS WRITTEN IN THE SELECT STATEMENT TO BE SORTED 
--	AND THEN USE THE NUMBER IN FRONT OF THE ORDER BY

SELECT FIRSTNAME, LASTNAME FROM Person.Person
ORDER BY 1 ASC;

SELECT FIRSTNAME, LASTNAME FROM Person.Person
ORDER BY 2 DESC;

-- LIMITING RECORDS 
-- WE DONT HAVE LIMIT LIKE WE HAD IN POSTGRES
-- INSTEAD WE USE THE 'TOP'
-- TOP IS USED AFTER THE SELECT STATEMENT 

--SHOW THE FIRST 50 NAMES 

SELECT top 50 FIRSTNAME, LASTNAME FROM Person.Person;


-- FITERING RECORDS 
-- WHERE => USED TO FILTER RECORDS 

-- OPERATORS => =,<,>,<=,>=,!=
SELECT * FROM Sales.SalesOrderHeader;
-- SHW ME INFO ABOUT CUSTOMER 11000

SELECT * FROM Sales.SalesOrderHeader
WHERE CustomerID = '11000';

-- WHEN FILTERING NUMBERS, WE MAY/MAY NOT USE THE ''

SELECT * FROM HumanResources.Employee
WHERE JobTitle = 'Chief Executive Officer';

-- GET INFO OF PRODUCTS WITH LISTPRICE GREATER THAN 1000
SELECT * FROM Production.Product;

SELECT * FROM Production.Product
WHERE ListPrice > 1000;

-- ALL THE ORDERS FOR JULY 5, 2011 => 2011-07-05

SELECT * FROM SALES.SalesOrderHeader
WHERE OrderDate = '2011-07-05';

SELECT * FROM SALES.SalesOrderHeader
WHERE OrderDate > '2011-07-05';

-- LOGICAL OPERATORS => AND, OR 
-- AND => BOTH CONDITION MUST BE TRUE 
-- OR => AT LEAST ONE OF THE CONDITION MUST BE TRUE 
-- GET INFO OF PERSON WHOSE NAME IS KEN MYER
SELECT FirstName,LASTNAME FROM PERSON.Person
WHERE FIRSTNAME =  'Ken' and lastname = 'Myer';

SELECT FirstName,LASTNAME FROM PERSON.Person
WHERE FIRSTNAME =  'Ken' or lastname = 'Myer';


-- PREDICATES => BETWEEN, IN, LIKE

-- BETWEEN 
-- USED WHEN WE HAVE RANGE OF VALUES
-- USED TO REPLACE <= OR >=

-- WE WANT PRODUCT WHOSE PRICES ARE GREATER THAN 100 AND LESS THAN 500

SELECT NAME, LISTPRICE FROM Production.Product
WHERE LISTPRICE >= 100 AND ListPrice <= 500;

SELECT NAME, LISTPRICE FROM Production.Product
WHERE LISTPRICE BETWEEN 100 AND 500;

-- GET INFO OF ORDERS OF SALES IN JULY 2011
-- JULY 2011 => 2011-07
-- RANGE OF VALUES => 2011-07-01 AND 2011-07-31

SELECT * FROM SALES.SalesOrderHeader
WHERE OrderDate BETWEEN '2011-07-01' AND '2011-07-31';

-- NOT BETWEEN 
-- NEGATION OF BETWEEN 
SELECT NAME, LISTPRICE FROM Production.Product
WHERE LISTPRICE NOT BETWEEN 100 AND 500
ORDER BY LISTPRICE DESC ;

-- IN 
-- In statement is used to replace multiple = SIGN
-- GET THE PRODUCT THAT ARE BLUE, RED AND BLACK

SELECT NAME, COLOR FROM Production.Product
WHERE COLOR = 'BLUE' OR COLOR = 'RED' OR COLOR = 'BLACK'
ORDER BY 2 DESC;

SELECT NAME, COLOR FROM Production.Product
WHERE COLOR IN ('BLUE','RED','BLACK')
ORDER BY 2 DESC;

SELECT NAME, COLOR FROM Production.Product
WHERE COLOR IN ('BLUE','RED','BLACK')
ORDER BY 2 DESC;


-- NOT IN 
-- NEGATION OF IN 
SELECT NAME, COLOR FROM Production.Product
WHERE COLOR NOT IN ('BLUE','RED','BLACK')
ORDER BY 2 DESC;

-- GET THE PRODUCT THAT ARE NOT BLUE, RED AND BLACK

SELECT NAME, COLOR FROM Production.Product
WHERE COLOR != 'BLUE' OR COLOR != 'RED' OR COLOR != 'BLACK'
ORDER BY 2 DESC;

SELECT NAME, Color FROM Production.Product
WHERE COLOR != 'BLUE' OR COLOR != 'RED' OR COLOR != 'BLACK';

-- LIKE 
-- USED FOR PATTERN MATCHING
-- The LIKE operator is used in a WHERE clause to search for a specified pattern in a column. 
-- IT HAS ITS OWN SYMBOLS => %, _
-- % => A WILDCARD,
--  => USED WHEN WE ARE NOT SURE OF THE NUMBER OF CHARACTERS /AS MANY CHARACTERS AS POSSIBLE 
--_ => WHEN WE ARE SURE, ONE _ MEANS ONE CHARACTER

-- GET THE NAMES OF PEOPLE HAVING 'SAND' BEGINNING THEIR LAST NAMES

SELECT FIRSTNAME, LASTNAME FROM PERSON.Person
WHERE LASTNAME LIKE 'SAND%';

SELECT FIRSTNAME, LASTNAME FROM PERSON.Person
WHERE LASTNAME LIKE 'SAND_';


-- FIND INFO OF PRODUCTS WITH 'DERAILLEUR'
SELECT NAME, LISTPRICE, COLOR FROM Production.Product
WHERE NAME LIKE '%DERAILLEUR%';


-- WORKING WITH NULLS
SELECT COLOR FROM Production.Product;

-- SEARCHING FOR NULL => IS NULL
SELECT COLOR FROM Production.Product
WHERE COLOR IS NULL;

-- REPLACING NULL VALUES => ISNULL
SELECT ISNULL (COLOR, 'NO COLOR') COLOR FROM Production.Product;

--REMOVING NULL VALUES => IS NOT NULL
SELECT COLOR FROM Production.Product
WHERE COLOR IS NOT NULL;

-- COALESCE, NULLIF => READUP


-- AGGREGATE FUNCTIONS 
-- THEY COME INSIDE THE SELECT STATEMENT
-- THEY CHANGE THE COLUMN'S NAME
-- THE AGGREGATED COLUMNS ARE USUALLY WITHIN THE BRACKETS ()
-- THEY USUALLY STAND ALONE UNLESS USED WITH GROUP BY STATEMENT

-- MIN
-- RETURNS THE MINIMUM VALUE IN A COLUMN
SELECT MIN(LISTPRICE) FROM Production.Product;

SELECT MIN(LISTPRICE) MIN_PRICE FROM Production.Product;

-- MAX
-- RETURNS THE MAXIMUM VALUE, HIGHEST VALUE

SELECT MAX(LISTPRICE) MAX_PRICE FROM Production.Product;

-- AVG
-- RETURNS THE AVERAGE MEAN OF THE VALUES 
SELECT AVG(LISTPRICE)  AVG_PRICE FROM Production.Product;

-- SUM
-- RETURNS THE SUM TOTAL OF THE VALUES
SELECT SUM(LISTPRICE) TOTAL_PRICE FROM Production.Product;
-- COUNT
-- COUNTS THE ROWS OR GIVES US THE FREQUENCY 
SELECT COUNT(LISTPRICE) PRICE_FREQ FROM Production.Product;

-- STDEV
-- STANDARD DEVIATION 
SELECT STDEV(LISTPRICE) STAND_DEV FROM Production.Product;

-- VAR
-- VARIANCE
SELECT VAR(LISTPRICE) VARIANCE FROM Production.Product;

-------------------------------------------------------------
-- JOINS
-- ==>JOINS ARE USED TO MERGE TWO OR MORE TABLES TOGETHER 
-- ==>THEY MUST SATISFY A MATCHING CRITERIA
-- ==>IT IS BASED ON PRI-FOREIGN KEY RELATONSHIP

-- HOW TO JOIN 
-- IDENTIFY THE TABLES WE ARE JOINING 
-- TAKE NOTE OF THE RELATIONSHIP KEYS (PRIMARY & FOREIGN KEYS)
-- TAKE NOTE OF THE COLUMNS NEEDED AND THE TABLE THE COLUMNS APPEAR 
-- MERGE THE COLUMNS TOGETHER IN THE SELECT STATEMENT
-- STATE THE JOIN TYPE 
-- ADD THE SECOND TABLE 
-- INTRODUCE THE JOINING CONDITION = (ON) WITH RELATIONSHIP
-- TO AVOID AMBIGOUS COLUMN:
	-- WE CAN ALIAS OUR TABLES NAMES 
	-- WE USE THE TABLE.COLUMNNAME FOR THE AMBIGOUS COLUMN


-- INNER JOIN 
-- => GET THE NAMES OF EMPLOYEES IN THE ORGANISATION
SELECT * FROM HumanResources.Employee;
-- BUSINESSENTITYID, JOBTITLE 
SELECT * FROM Person.Person;
-- BUSINESSENTITYID, FIRSTNAME, LASTNAME

--==> BUSINESSENTITYID IS COMMON TO BOTH TABLES 

SELECT HRE.BUSINESSENTITYID, JOBTITLE, PP.BUSINESSENTITYID, FIRSTNAME, LASTNAME
FROM HumanResources.Employee HRE INNER JOIN Person.Person PP
ON HRE.BusinessEntityID = PP.BusinessEntityID;

SELECT HRE.BUSINESSENTITYID, FIRSTNAME, LASTNAME,  JOBTITLE
FROM HumanResources.Employee HRE INNER JOIN Person.Person PP
ON HRE.BusinessEntityID = PP.BusinessEntityID;

-- OUTER JOIN
-- LEFT OUTER JOIN
-- ==> GET THE CUSTOMERS INFO WHETHER THEY HAVE ORDERED OR NOT 
SELECT * FROM Sales.Customer;
-- CUSTOMERID, ACCOUNTNO
SELECT* FROM SALES.SalesOrderHeader;
-- SALESORDERID, ORDERDATE, SALESORDERNUMBER
-- CUSTOMERID IS COMMON TO BOTH

SELECT C.CUSTOMERID, C.AccountNumber, SALESORDERID, ORDERDATE, SALESORDERNUMBER
FROM SALES.Customer C LEFT JOIN SALES.SalesOrderHeader H
ON C.CustomerID = H.CustomerID

-- RIGHT OUTER JOIN 
SELECT HRE.BUSINESSENTITYID, FIRSTNAME, LASTNAME,  JOBTITLE
FROM HumanResources.Employee HRE RIGHT JOIN Person.Person PP
ON HRE.BusinessEntityID = PP.BusinessEntityID
ORDER BY 1 DESC;

-- FULL JOIN

SELECT HRE.BUSINESSENTITYID, FIRSTNAME, LASTNAME,  JOBTITLE
FROM HumanResources.Employee HRE FULL JOIN Person.Person PP
ON HRE.BusinessEntityID = PP.BusinessEntityID
ORDER BY 1 DESC;

-- LETS FETCH THE NAMES OF OUR CUSTOMERS 
SELECT * FROM SALES.Customer;
-- CUSTOMERID 
SELECT * FROM Person.Person;
-- FIRSTNAME, LASTNAME

-- THE PERSONID IN THE CUSTOMER TABLE MATCHES THE BUSINESSENTITYID IN THE PERSON.PERSON TABLE

SELECT CUSTOMERID, FIRSTNAME, LASTNAME, BusinessEntityID
FROM Sales.Customer INNER JOIN Person.Person
ON PersonID = BusinessEntityID
ORDER BY 4;

-- GROUP BY
-- ==> USED TO GROUP RECORDS 
-- ==> USUALLY USED WITH AGGREGATE FUNCTIONS
SELECT* FROM Sales.SalesOrderDetail;

-- WHAT IS THE WORTH OF EACH SALESORDER 
SELECT SalesOrderID, SUM(LineTotal) TOTAL_AMOUNT FROM Sales.SalesOrderDetail
GROUP BY SalesOrderID;

-- HOW MANY TIME HAS EACH CUSTOMER PAATRONISED US 
SELECT * FROM SALES.SalesOrderHeader

SELECT CUSTOMERID, COUNT(TOTALDUE) FREQ FROM Sales.SalesOrderHeader
GROUP BY CUSTOMERID
ORDER BY 2 DESC;


SELECT CUSTOMERID, COUNT(TOTALDUE)FREQ, SUM(TOTALDUE) AMOUNT_SPENT FROM Sales.SalesOrderHeader
GROUP BY CUSTOMERID
ORDER BY 2 DESC;

-- HAVING
-- ==>USED TO FILTER GROUPED RECORDS
-- ==> IT CAN EVERYTHING 'WHERE' DOES 
-- ==> WORKS WITH BOTH OPERATORS AND PREDICATES

-- WE WANT TO KNOW THE PRODUCTS WHICH TOTAL SALES IS GREATER THAN 10000 AND AMOUNT OF PRODUCT SOLD

SELECT * FROM SALES.SalesOrderDetail

SELECT PRODUCTID, SUM(LINETOTAL) TOTAL_SALES, COUNT(PRODUCTID) TOTAL_PROD
FROM SALES.SalesOrderDetail
GROUP BY ProductID
HAVING SUM(LINETOTAL) > 10000
ORDER BY 2;

-- DATA DEFINITION LANGUAGE 

-- CREATE 
-- CREATE DATABASE
CREATE DATABASE QUANTUM_ANALYTICS;

-- CREATE TABLE
CREATE TABLE MARCH_COHORT(
	STUDENTNO INT PRIMARY KEY IDENTITY(1,1),
	NAME VARCHAR(50) NOT NULL,
	LOCATION VARCHAR(200) ,
	GENDER VARCHAR(2) NOT NULL
	);

-- INSERT INTO TABLE
INSERT INTO MARCH_COHORT (NAME, LOCATION, GENDER)
VALUES ('UKPEIGBE',' ', 'M'),
		('MARYSTELLA', 'LAGOS', 'F');

SELECT * FROM MARCH_COHORT;	

-- ALTER
-- DROP 

-- DELETE TABLES/ DATABASES
--DROP DATABASE QUANTUM_ANALYTICS;
--DROP TABLE MARCH_COHORT;

-- DELETE ROWS
DELETE FROM MARCH_COHORT
WHERE STUDENTNO = 1;

SELECT * FROM MARCH_COHORT

-- UPDATE 
UPDATE MARCH_COHORT
SET LOCATION = 'BI'
WHERE STUDENTNO = 4;

SELECT * FROM MARCH_COHORT;

-- UNION/UNIONALL


-- PRACTICE 
-- DO YOUR ASSIGNMENT

-- CONNECT WITH ME ON LINKEDIN 
-- https://www.linkedin.com/in/abdullahbankole/

-- WRITTEN BY ABDULLAH BANKOLE 
-- THANK YOU FOR CHOOSING QUANTUM ANALYTICS

----------------------------------------------------------
USE QUANTUM_ANALYTICS

CREATE TABLE MARCH_COHORT(
	STUDENTNO INT PRIMARY KEY IDENTITY(1,1),
	NAME VARCHAR(50) NOT NULL,
	LOCATION VARCHAR(200) ,
	GENDER VARCHAR(2) NOT NULL
	)

INSERT INTO MARCH_COHORT (NAME, LOCATION, GENDER)
VALUES ('UKPEIGBE',' ', 'M'),
		('MARYSTELLA', 'LAGOS', 'F');


