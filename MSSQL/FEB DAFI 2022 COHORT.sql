-- FEB MSSQL DAFI COHORT 

-- SELECT - FROM STATEMENT 
-- used to fetch a column, MLTIPLES columns or all of the columns in a table.

-- SELECT ALL (*)

SELECT * FROM Person.Person;

SELECT * FROM HumanResources.Employee;

SELECT * FROM [Production].[ProductInventory];

-- SELECT MULITPLE COLUMNS 
SELECT ProductID, LocationID, Shelf, Quantity FROM Production.ProductInventory;

-- select single columns 

select Shelf from Production.ProductInventory;


-- REMOVING DUPLICATES 
-- SELECT DISTINCT 

SELECT DISTINCT SHELF FROM Production.ProductInventory;

SELECT DISTINCT ListPrice FROM Production.Product;

-- SORTING RECORDS
-- ORDER BY
-- ASC = ASCENDING = SMALLEST - BIGGEST/ LOWEST- HIGHEST
-- DESC = DESCENDING = HIGHEST - LOWEST/ BIGGEST - SMALLEST

SELECT FirstName, LastName FROM PERSON.PERSON
ORDER BY FirstName ASC;

SELECT FirstName, LastName FROM PERSON.PERSON
ORDER BY FirstName ;

SELECT FirstName, LastName FROM PERSON.PERSON
ORDER BY LastName DESC;

-- LIMITING SORTED RECORDS
-- WE USE TOP n TO LIMIT THE RECORDS 
-- THE TOP USUALLY COMES AFTER THE SELECT STATEMENT
-- N =  THE NUMBER OF ROWS WE ARE LIMITING 

SELECT TOP 50 FirstName, LastName FROM PERSON.PERSON
ORDER BY LastName DESC;

-- FILTERING RECORDS
-- WHERE 

-- GET ALL INFO ON THE PRODUCT "BLADE"

SELECT * FROM Production.Product
WHERE NAME = 'BLADE';

-- GET INFO OF PRODUCTS WITH LISTPRICE GREATER THAN 1000

SELECT * FROM Production.Product
WHERE ListPrice > 1000;

-- we want name, color and listprice of black products greater than 1000
-- 
-- Ojerime
SELECT NAME, COLOR, LISTPRICE FROM Production.Product
WHERE COLOR = 'BLACK';

-- Victoria
SELECT NAME, COLOR, LISTPRICE FROM Production.Product
WHERE COLOR = 'BLACK' AND ListPrice > 1000;

-- we want name, color and listprice OF productS THAT ARE either less than $100 or greater than $1000
-- MR OSU
SELECT NAME , COLOR, LISTPRICE FROM Production.Product
WHERE LISTPRICE < 100 OR LISTPRICE > 1000;


-- LIKE STATEMENT

-- The LIKE operator is used in a WHERE clause to search for a specified pattern in a column. 
-- % = WHEN WE ARE NOT SURE OF THE NUMBER OF CHARACTERS/ AS MANY CHARACTERS AS POSSIBLE 
-- _ = WHEN WE ARE SURE, ONE _ MEANS ONE CHARACTER
-- IN MSSQL SERVER, IT IS NOT CASE SENSITIVE, WHEREAS IN OTHER BRAND OF SQL E.G. MYSQL, POSTGRESQL, IT IS CASE SENSITIVE 

--
-- INFO ON PRODUCTS THAT STARTS WITH BEARING

SELECT * FROM Production.Product
WHERE NAME LIKE 'BEARING%';

-- WE WANT BUSINESSENTITITYID, FIRSTNAME, LASTNAME OF PEOPLE WHOSE FIRST NAMES END WITH ER

SELECT BUSINESSENTITYID, FIRSTNAME, LASTNAME FROM Person.Person
WHERE FirstName LIKE '%ER';

-- WE WANT THOSE WHOSE FIRST NAME STARTS WITH A AND THOSE WHOSE FIRST NAME STARTS WITH Z
SELECT FIRSTNAME, LASTNAME FROM PERSON.PERSON
WHERE FIRSTNAME LIKE 'A%' OR FirstName LIKE 'Z%';

-- WE WANT FIRSTNAME, LASTNAME OF THOSE WHOSE FIRST NAME STARTS WITH B AND THOSE WHOSE LAST NAME STARTS WITH W
SELECT FirstName, LASTNAME FROM Person.Person
WHERE FirstName LIKE 'B%' AND LastName LIKE 'W%';

-- IN STATEMENT 
-- In statement is used to replace multiple =

-- GIVE INFO ON name, color and listprice OF PRODUCTS THAT ARE BLACK AND RED 
SELECT NAME , COLOR, LISTPRICE FROM Production.Product
WHERE COLOR = 'BLACK' OR COLOR = 'RED';

-- GIVE INFO ON name, color and listprice OF PRODUCTS THAT ARE BLACK, RED, MULTI, BLUE 
SELECT NAME , COLOR, LISTPRICE FROM Production.Product
WHERE COLOR = 'BLACK' OR COLOR = 'RED' OR COLOR = 'MULTI' OR COLOR = 'BLUE';

-- USING IN
SELECT NAME , COLOR, LISTPRICE FROM Production.Product
WHERE COLOR IN ('BLACK', 'RED', 'MULTI', 'BLUE');

-- NOT IN 
SELECT NAME , COLOR, LISTPRICE FROM Production.Product
WHERE COLOR NOT IN ('BLACK', 'RED', 'MULTI', 'BLUE');

-- BETWEEN 
-- USED WHEN WE HAVE RANGE OF VALUES
-- USED TO REPLACE <= OR >=

-- WE WANT PRODUCT WHOSE PRICES ARE GREATER THAN 100 AND LESS THAN 500
SELECT * FROM Production.Product
WHERE ListPrice >= 100 AND LISTPRICE <= 500;

SELECT * FROM Production.Product
WHERE ListPrice BETWEEN 100 AND 500;

-- NOT BETWEEN 
SELECT * FROM Production.Product
WHERE ListPrice NOT BETWEEN 100 AND 500;

-- Write a query using a WHERE clause that displays all the names in Person.Person with the middle name J 
-- and lastname starts with SE. Display the first, last, and middle names along with the ID numbers.
select * from Person.Person;

-- VICTORIA mediumly correct
select businessentityid, firstname, middlename, lastname from person.Person
where middlename = 'J' and LastName LIKE 'SE%' 

-- MR OSU not too correct
SELECT FIRSTNAME, MIDDLENAME, LASTNAME, BUSINESSENTITYID FROM PERSON.PERSON
WHERE MiddleName LIKE 'J%' and FirstName like 'SE%'

-- Ojerime Correct
select businessentityid, firstname, middlename, lastname from person.Person
where middlename like 'J%' and LastName LIKE 'SE%' 

-- AGGREGATE FUNCTIONS 
-- THEY COME INSIDE THE SELECT STATEMENT
-- THEY CHANGE THE COLUMNS NAME
-- THE AGGREGATED COLUMNS ARE USUALLY WITHIN THE BRACKETS ()
-- THEY USUALLY STAND ALONE UNLESS USED WITH GROUP BY STATEMENT

-- SUM
-- SUMS UP ALL THE VALUES 
SELECT SUM(LISTPRICE) FROM PRODUCTION.PRODUCT;

-- MIN
-- GIVES THE MINIMUM VALUE
SELECT MIN(LISTPRICE) FROM PRODUCTION.PRODUCT;

-- MAX
-- RETURNS THE MAXIMUM VALUE, HIGHEST VALUE
SELECT MAX (LISTPRICE) FROM Production.Product

-- VAR
-- RETURNS THE VARIANCE OF THE VALUE
SELECT VAR(LISTPRICE) FROM Production.Product

-- STDEV
-- RETURNS THE STANDARD DEVIATION OF THE VALUES
SELECT STDEV(LISTPRICE) FROM Production.Product;

-- AVG 
-- RETURNS THE AVERAGE MEAN OF THE VALUES 
SELECT AVG(LISTPRICE) FROM Production.Product;
-- COUNT 
-- COUNT THE NUMBER OF VALUES 

SELECT COUNT(LISTPRICE) FROM PRODUCTION.Product;

SELECT COUNT(LISTPRICE), AVG(LISTPRICE), MIN(LISTPRICE), MAX(LISTPRICE) FROM PRODUCTION.PRODUCT;

-- ALIASES 
-- AS IS USED TO CHANGE THE NAMES OF COLUMNS OR TABLES
SELECT COUNT(LISTPRICE) AS PRD_COUNT FROM PRODUCTION.Product;

-- WITHOUT AS ALSO WORKS
SELECT MIN(LISTPRICE) MIN_PRICE FROM Production.Product;

SELECT COUNT(LISTPRICE) AS PRD_COUNT, AVG(LISTPRICE) AVG_PRICE, MIN(LISTPRICE) MIN_PRICE, 
MAX(LISTPRICE) MAX_PRICE FROM PRODUCTION.PRODUCT;


-- GROUPING RECORDS
-- GROUP BY 

SELECT * FROM SALES.SalesOrderDetail;

SELECT SALESORDERID, SUM(LINETOTAL) TOTAL_AMOUNT FROM SALES.SalesOrderDetail
GROUP BY SalesOrderID;

-- HAVING 
-- HAVING IS USED TO FILTER THROUGH GROUPED RECORDS 
-- IT DOES EVERYTHING THAT A WHERE CLAUSE CAN DO
-- WE CAN USE LIKE, BETWEEN, <,>, =, IN, NOT IN ETC

-- WE WANT TO KNOW THE PRODUCTS WHICH TOTAL SALES IS GREATER THAN 10000 AND AMOUNT OF PRODUCT SOLD
SELECT * FROM SALES.SalesOrderDetail;

SELECT PRODUCTID, SUM(LINETOTAL) TOTAL_SALES, COUNT(PRODUCTID) PRD_COUNT FROM SALES.SalesOrderDetail
GROUP BY PRODUCTID
HAVING SUM(LINETOTAL) > 10000;

-- IF WE WANT TO GET OUR MOST PERFORMING PRODUCT 
SELECT PRODUCTID, SUM(LINETOTAL) TOTAL_SALES, COUNT(PRODUCTID) PRD_COUNT FROM SALES.SalesOrderDetail
GROUP BY PRODUCTID
HAVING SUM(LINETOTAL) > 10000
ORDER BY 3 DESC;

SELECT PRODUCTID, SUM(LINETOTAL) TOTAL_SALES, COUNT(PRODUCTID) PRD_COUNT FROM SALES.SalesOrderDetail
GROUP BY PRODUCTID
HAVING SUM(LINETOTAL) > 10000
ORDER BY 2 DESC;

-- ASSIGNMENT 
-- How many products do we have per color

-- MR EMMANUEL

SELECT * FROM Production.Product
SELECT PRODUCTID, COLOR FROM PRODUCTION.PRO

SELECT DISTINCT PRODUCTID FROM PRODUCTION.Product
SELECT DISTINCT COLOR FROM Production.Product
SELECT COLOR = COUNT(*) FROM Production.Product
-- confused??
SELECT COUNT(COLOR) AS PRD_COUNT FROM PRODUCTION.Product
WHERE COLOR NOT IN ('NULL')
group by color
-- YOU COULD ADD COLOR
SELECT COLOR, COUNT(COLOR) AS PRD_COUNT FROM PRODUCTION.Product
--WHERE COLOR NOT IN ('NULL')
group by color



-- OJERIME


SELECT DISTINCT COLOR, COUNT(PRODUCTID) AS PRODUCT_ID, COUNT(COLOR) AS QUANTITY FROM Production.Product
	GROUP BY COLOR;

SELECT DISTINCT COLOR, COUNT(COLOR) AS QUANTITY FROM Production.Product
GROUP BY COLOR;
-- NO NEED FOR DISTINCT SICE YOU ARE GROUPING 
SELECT  COLOR, COUNT(ProductID) AS QUANTITY FROM Production.Product
GROUP BY COLOR;


-- VICTORIA
SELECT COLOR, COUNT(PRODUCTID) AS PRD_ID FROM PRODUCTION.Product
GROUP BY COLOR;
-- WORK ON YOUR RENAMING 

-- Mr Olushola
-- How many products do we have per color
SELECT COLOR, COUNT(PRODUCTID) AS PRO_ID FROM Production.Product
WHERE COLOR NOT IN ('NULL')
GROUP BY COLOR;
-- What happens to product with null colors?
SELECT COLOR, COUNT(PRODUCTID) AS PRO_ID FROM Production.Product
GROUP BY COLOR;

--Mr Mikaiola
-- How many products do we have per color
SELECT COLOR, COUNT(PRODUCTID) AS NUMBER_PRODUCT FROM Production.Product
WHERE COLOR NOT IN ('null') 
Group by color 
-- What happens to product with null colors?
-- SAME AS MR OLUSHOLA

-- MR ELOCHUKWU
--How many products do we have per color
SELECT * FROM Production.Product

SELECT COUNT(PRODUCTID) PRO_COUNT, COLOR FROM Production.Product
GROUP BY COLOR
-- 
SELECT COLOR, COUNT(PRODUCTID) PRO_COUNT FROM Production.Product
GROUP BY COLOR

-- MADAME NOFISAT
-- How many products do we have per color
SELECT NAME, PRODUCTID, COLOR FROM PRODUCTION.Product
SELECT DISTINCT COUNT(COLOR) FROM PRODUCTION.Product

SELECT DISTINCT COUNT(PRODUCTID), COUNT(COLOR) FROM Production.PRODUCT
--WHERE COLOR = 'NULL'
GROUP BY COLOR	
-- NO NEED FOR DISTINCT SICE YOU ARE GROUPING
SELECT COLOR,  COUNT(PRODUCTID) FROM Production.PRODUCT
GROUP BY COLOR	

-- MR OSU 
-- How many products do we have per color
SELECT * FROM PRODUCTION.PRODUCT;

SELECT COUNT(PRODUCTID) PRODUCT_COUNT, COLOR FROM PRODUCTION.PRODUCT
GROUP BY COLOR;
--
SELECT COLOR,  COUNT(PRODUCTID) PRODUCT_COUNT FROM PRODUCTION.PRODUCT
GROUP BY COLOR;

-- JOINS
-- JOINS ARE USED TO MERGE TWO OR MORE TABLES TOGETHER 
-- THEY MUST SATISFY A MATCHING CRITERIA
-- IT IS BASED ON PRI-FOREIGN KEY RELATONSHIP

-- HOW TO JOIN 
-- IDENTIFY THE TABLES WE ARE JOINING 
-- TAKE NOTE OF THE RELATIONSHIP KEYS (PRIMARY & FOREIGN KEYS)
-- TAKE NOTE OF THE COLUMNS NEEDED AND THE TABLE THE COLUMNS APPEAR 
-- STATE THE JOIN TYPE 
-- ADD THE SECOND TABLE 
-- INTRODUCE THE JOINING CONDITION = (ON) WITH RELATIONSHIP
-- TO AVOID AMBIGOUS COLUMN;
	-- WE CAN ALIAS OUR TABLES NAMES 
	-- WE USE THE TABLE.COLUMNNAME FOR THE AMBIGOUS COLUMN




--- TYPES
-- INNER
-- FETCH THE NAMES OF THE EMPLOYEES IN THE ORGANIZATION
SELECT * FROM HumanResources.Employee;
-- BUSINESSENTITYID,JOBTITLE
SELECT * FROM PERSON.Person;
-- BUSINESSENTITYID, FIRSTNAME, LASTNAME 

SELECT HRE.BUSINESSENTITYID,JOBTITLE, PP.BUSINESSENTITYID, FIRSTNAME, LASTNAME 
FROM HumanResources.Employee AS HRE INNER JOIN PERSON.Person PP
ON HRE.BusinessEntityID = PP.BusinessEntityID;

SELECT HRE.BUSINESSENTITYID,FIRSTNAME, LASTNAME, JOBTITLE  
FROM HumanResources.Employee AS HRE INNER JOIN PERSON.Person PP
ON HRE.BusinessEntityID = PP.BusinessEntityID;

-- OUTER
-- LEFT OUTER
SELECT HRE.BUSINESSENTITYID,FIRSTNAME, LASTNAME, JOBTITLE  
FROM HumanResources.Employee AS HRE LEFT JOIN PERSON.Person PP
ON HRE.BusinessEntityID = PP.BusinessEntityID;

-- SHOW CUSTOMERS WHETHER THEY HAVE ORDERED OR NOT  
SELECT * FROM Sales.Customer;
-- CUSTOMERID

SELECT * FROM Sales.SalesOrderHeader;
--SALESORDERID, SALESORDERNUMBER, CUSTOMERID

SELECT SC.CUSTOMERID, SALESORDERID, SALESORDERNUMBER, SOH.CUSTOMERID
FROM Sales.Customer SC LEFT JOIN SALES.SalesOrderHeader SOH
ON SC.CustomerID = SOH.CustomerID



-- RIGHT OUTER 
SELECT HRE.BUSINESSENTITYID,FIRSTNAME, LASTNAME, JOBTITLE  
FROM HumanResources.Employee AS HRE RIGHT JOIN PERSON.Person PP
ON HRE.BusinessEntityID = PP.BusinessEntityID;

SELECT HRE.BUSINESSENTITYID, JOBTITLE , FIRSTNAME, LASTNAME
FROM HumanResources.Employee AS HRE RIGHT JOIN PERSON.Person PP
ON HRE.BusinessEntityID = PP.BusinessEntityID;



-- FULL OUTER 
-- MERGES ALL TOGETHER
SELECT SC.CUSTOMERID, SALESORDERID, SALESORDERNUMBER, SOH.CUSTOMERID
FROM Sales.Customer SC FULL JOIN SALES.SalesOrderHeader SOH
ON SC.CustomerID = SOH.CustomerID
-- SELF JOIN 



-- TABLE CREATION 
-- CREATE TABLES 
-- 01: WE USE THE SYNTAX = CREATE TABLE TABLENAME ()
-- 02: WE ADD THE COLUMN NAMES WITHIN THE BRACKETS
-- 03: WE ADD THE DATATYPES TO EACH COLUMN
-- 04: WE SPECIFY RELATIONSHIP (PRIMARY, ETC)
-- 05: WE ADD CONSTRAINT (UNIQUE, NOT NULL, IDENTITY)
-- IDENTITY = USED TO AUTOMATE VALUES E.G 1,2,3,4,5


CREATE TABLE SEM1(
STUDENTID INT PRIMARY KEY IDENTITY(1,1),
S_NAME VARCHAR(20) NOT NULL,
COURSE VARCHAR(10) NOT NULL,
SCORES INT NOT NULL) 

-- INSERTING RECORDS INTO TABLE
 INSERT INTO SEM1 (S_NAME, COURSE, SCORES)
 VALUES ('NOFISAT', 'MYSQL', '29'),
		('VICTORIA', 'MSSQL', '28'),
		('BARTHO', 'EXCEL', '29')

SELECT * FROM SEM1 

-- METHOD 2 
CREATE TABLE SEM2(
STUDENTID INT PRIMARY KEY IDENTITY(1,1),
S_NAME VARCHAR(20) NOT NULL,
COURSE VARCHAR(10) NOT NULL,
SCORES INT NOT NULL) 

SELECT * FROM SEM2;

-- TABLE DELETION
-- DROP TABLE SEM1;

-- SET OPERATORS
-- USED TO COMNBINE TWO OR MORE SELECT STATMENTS
-- RULES
-- no of columns must be the same
-- order of columns must be the same 
-- datatypes of the columns must be the same


-- UNION
-- USED TO COMNBINE TWO OR MORE SELECT STATEMENTS WITHOUT DUPLICATES
SELECT * FROM SEM1 
UNION 
SELECT * FROM SEM2 


-- UNION ALL
-- USED TO COMNBINE TWO OR MORE SELECT STATEMENTS WITH DUPLICATES
SELECT * FROM SEM1 
UNION ALL
SELECT * FROM SEM2 


-- INTERSECT
-- returns only the common ROW value in the two select statement
SELECT * FROM SEM1 
INTERSECT
SELECT * FROM SEM2 

-- EXCEPT
-- shows all the records on the left table but on the right table including duplicate
SELECT * FROM SEM1 
excepT
SELECT * FROM SEM2 



-- MISCELLANEOUS 
-- working with dates
-- cast operator
-- youtube!!!
-- google 
-- w3schools


-- connect with me on linkedin
-- Abdullah Bankole
-- https://www.linkedin.com/in/abdullahbankole/

-- THANKS FOR CHOOSING QUANTUM ANALYTICS