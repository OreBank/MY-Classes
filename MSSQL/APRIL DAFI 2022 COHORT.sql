-- DAFI APRIL COHORT 2022 
-- MSSQL DAY 02
-- FACILITATED BY: ABDULLAH BANKOLE

-- SELECT STATEMENT 
-- USED TO FETCH COLUMN(S) FROM A TABLE
-- WE CAN FETCH A SINGLE COLUMN, MULTIPLE COLUMNS, AL THE COLUMNS FROM A TABLE 


-- ALL COLUMNS
-- WE USE THE * AFTER THE SELECT STATEMENT 

SELECT * FROM Production.Product;

-- MULTIPLE COLUMNS 
-- WE INSERT THE COLUMN NAMES AFTER THE SELECT STATEMENT 

SELECT PRODUCTID, NAME, COLOR FROM Production.Product;


-- SINGLE COLUMN 

SELECT NAME FROM PRODUCTION.PRODUCT;

-- REMOVIG DUPLICATE RECORDS 
-- ==> WE USE 'DISTINCT' AFTER THE SELECT STATEMENT TO REMVOE DUPLICATE RECORDS 

SELECT COLOR FROM Production.Product;

SELECT DISTINCT COLOR FROM Production.Product;

-- SORTING RECORDS 
-- WE USED 'ORDER BY' TO SORT RECORDS 
-- SORT = ARRANGE 
-- ASCENDING ==> ASC ==> SMALLEST TO THE BIGGEST
-- DESCENDING ==> DESC ==> TOP TO BOTTOM 

SELECT * FROM Purchasing.PurchaseOrderHeader
ORDER BY TotalDue ASC;

SELECT * FROM Purchasing.PurchaseOrderHeader
ORDER BY TotalDue DESC;

--  Write a SELECT statement that lists the customer ID numbers and sales order ID

-- TOLU
SELECT * FROM Sales.SalesOrderHeader

SELECT SalesOrderID, CustomerID FROM Sales.SalesOrderHeader

-- FETCH THE FIRST AND LAST NAMES OF EVERYONE IN THE COMPANY ARRANGED FORMALLY

SELECT FirstName, LastName FROM Person.Person
ORDER BY LASTNAME;

-- ALIASES 
-- USED TO RENAME COLUMNS OR TABLES 
-- AS KEYWORD IS USED 
-- OR WE USE A SPACE BETWEEN THE OLD NAME AND THE NEW NAME 


SELECT FirstName, LASTNAME AS SURNAME FROM Person.Person;

-- LIMITING RECORDS 

SELECT * FROM Production.Product;

-- IN MYSQL, WE USED LIMIT N TO SORT RECORDS 
-- IN T-SQL, WE USE TOP N 
-- THE TOP N  IS USUALLY AFTER THE SELECT STATEMENT

SELECT TOP 20 * FROM Production.Product;

SELECT TOP 2 FirstName, LASTNAME AS SURNAME FROM Person.Person;

-- FILTERING RECORDS 
-- WHERE IS THE MOTHER OF ALL FILTERS
-- PREDICATE: BETWEEN, LIKE, NOT, IN
-- OPERATORS: =, <, >, ! ETC

-- OPERATORS 
-- GET ALL INFO OF PRODUCT "Blade"

SELECT * FROM Production.Product
WHERE NAME = 'Blade';

-- GET INFO OF PRODUCTS WITH LISTPRICE GREATER THAN 1000

select * from Production.Product
where ListPrice > 1000;

-- we want name, color and listprice of black products greater than 1000
select name, color, listprice from Production.Product
where Color = 'black' and  listprice > 1000;

-- Predicates
-- IN 
-- In statement is used to replace multiple '=' sign

-- GIVE INFO ON name, color and listprice OF PRODUCTS THAT ARE BLACK, RED and Yellow

SELECT NAME, COLOR, LISTPRICE FROM Production.Product
WHERE COLOR IN ('BLACK', 'RED', 'YELLOW');

--NOT IN 
--NEGATION OF IN
SELECT NAME, COLOR, LISTPRICE FROM Production.Product
WHERE COLOR NOT IN ('BLACK', 'RED', 'YELLOW');

-- BETWEEN 
-- USED WHEN WE HAVE RANGE OF VALUES
-- USED TO REPLACE <= OR >=

-- WE WANT PRODUCT WHOSE PRICES ARE GREATER THAN 100 AND LESS THAN 500

SELECT NAME, LISTPRICE FROM Production.Product
WHERE LISTPRICE BETWEEN 100 AND 500;

-- LIKE 
-- USED FOR PATTERN FILTERING 
-- % = WHEN WE ARE NOT SURE OF THE NUMBER OF CHARACTERS/ AS MANY CHARACTERS AS POSSIBLE 
-- _ = WHEN WE ARE SURE, ONE _ MEANS ONE CHARACTER

-- INFO ON PRODUCTS THAT STARTS WITH BEARING
SELECT * FROM Production.Product
WHERE NAME LIKE 'BEARING%'

-- THE INFO OF PEOPLE WITH SAND BEGINNIG THEIR LASTNAMES

SELECT * FROM PERSON.Person
WHERE LastName LIKE 'SAND%';

-- GET INFO OF PEOPLE WITH EL IN BETWEEN THEIR FIRSTNAMES 

SELECT * FROM PERSON.Person
WHERE FIRSTNAME LIKE'%EL%';

-- AGGREGATE FUNCTION

-- THEY COME INSIDE THE SELECT STATEMENT
-- THEY CHANGE THE COLUMNS NAME
-- THE AGGREGATED COLUMNS ARE USUALLY WITHIN THE BRACKETS ()
-- THEY USUALLY STAND ALONE UNLESS USED WITH GROUP BY STATEMENT

-- MIN ==> MINIMUM VALUE
SELECT MIN(LISTPRICE) AS MIN_PRICE FROM Production.Product

-- MAX ==> MAXIMUM VALUE
SELECT MAX(LISTPRICE) AS MAX_PRICE FROM Production.Product
-- AVG ==> AVEGRAGE MEAN 
-- COUNT ==> FREQUENCY
SELECT * FROM Production.Product
SELECT COUNT(*) FROM Production.Product;
SELECT COUNT(COLOR) FROM Production.Product;

-- NOTE: WHEN USING COUNT, 
-- COUNT(*) ==> COUNTS ALL INCLUDING THE NULL VALUES
-- COUNT(COLUMNNAME) ==> DOESNT COUNT THE NULL VALUES

-- SUM ==>SUMMAATION
SELECT SUM(LISTPRICE) FROM Production.Product;



-- GROUPING RECORDS
SELECT * FROM Production.Product;

-- HOW MANY PRODUCT DO WE HAVE FOR EACH COLOR 

--NULL== 5
--BLACK == 3
--SILVER = 2

SELECT COUNT(PRODUCTID), COLOR FROM PRODUCTION.Product
GROUP BY Color;

SELECT COUNT(PRODUCTID) AS PRODUCTS, COLOR FROM PRODUCTION.Product
GROUP BY Color;

SELECT COUNT(PRODUCTID) AS PRODUCTS, COLOR FROM PRODUCTION.Product
GROUP BY Color
ORDER BY 1 ASC;

SELECT COUNT(PRODUCTID) AS PRODUCTS, COLOR FROM PRODUCTION.Product
GROUP BY Color
ORDER BY PRODUCTS ASC;

-- THE TOTAL AMOUNT MADE FROM EACH PRODUCT

SELECT * FROM SALES.SalesOrderDetail;

SELECT SUM(LINETOTAL) AS TOTAL_AMOUNT, PRODUCTID FROM Sales.SalesOrderDetail
GROUP BY ProductID
ORDER BY 1 ASC;

-- FILTERING GROUPED RECORDS 
-- HAVING ==> FILTER GROUPED RECORDS 
-- IT WORKS LIKE "WHERE"
-- WE CAN USE IT WITH:
-- OPERATORS ==> (>,<,=,!=, ETC)
-- PREDICATES ==> (BETWEEN, LIKE, IN)

-- WE WANT TO KNOW THE PRODUCTS WHOSE TOTAL SALES IS GREATER THAN 10000;

SELECT * FROM SALES.SalesOrderDetail;

SELECT PRODUCTID, SUM(LINETOTAL) AS TOTAL_SALES FROM SALES.SalesOrderDetail
GROUP BY PRODUCTID
HAVING SUM(LINETOTAL) > 10000
ORDER BY TOTAL_SALES;

-- WE WANT TO GET OUR MOST PERFORMING PRODUCT 
-- TOLU ==> IN TERMS OF FREQUENCY OF BUY
SELECT * FROM SALES.SalesOrderDetail;

SELECT PRODUCTID, COUNT(ORDERQTY) AS MOST_PERFORMING_PRODUCT FROM SALES.SalesOrderDetail
GROUP BY PRODUCTID
HAVING COUNT(ORDERQTY) > 1
ORDER BY 2 ASC;

--AHMAD==>
SELECT PRODUCTID, COUNT(ORDERQTY) AS MOST_PERFORMING_PRODUCT FROM SALES.SalesOrderDetail
GROUP BY PRODUCTID
ORDER BY 2 DESC;

-- CORRECTION BY US

SELECT PRODUCTID, SUM(ORDERQTY) AS MOST_PERFORMING_PRODUCT FROM SALES.SalesOrderDetail
GROUP BY PRODUCTID
ORDER BY 2 DESC;

-- MOST PERFORMING PRODUCT
SELECT TOP 1 PRODUCTID, SUM(ORDERQTY) AS MOST_PERFORMING_PRODUCT FROM SALES.SalesOrderDetail
GROUP BY PRODUCTID
ORDER BY 2 DESC;

SELECT TOP 1 PRODUCTID, SUM(LineTotal) AS MOST_PERFORMING_PRODUCT FROM SALES.SalesOrderDetail
GROUP BY PRODUCTID
ORDER BY 2 DESC;

SELECT PRODUCTID, SUM(ORDERQTY) BOUGHT, SUM(LineTotal) MADE  FROM SALES.SalesOrderDetail
GROUP BY PRODUCTID
ORDER BY 2 DESC;

SELECT PRODUCTID, SUM(ORDERQTY) BOUGHT, SUM(LineTotal) MADE  FROM SALES.SalesOrderDetail
GROUP BY PRODUCTID
ORDER BY 3 DESC;

-- JOINS
-- JOINS USED TO MERGE TWO OR MORE TABLES TOGETHER 
-- ==>JOINS ARE USED TO MERGE TWO OR MORE TABLES TOGETHER 
-- ==>THEY MUST SATISFY A MATCHING CRITERIA
-- ==>IT IS BASED ON PRIMARY-FOREIGN KEY RELATONSHIP

-- HOW TO JOIN
-- IDENTIFY THE TABLES WE ARE JOINING 
-- TAKE NOTE OF THE RELATIONSHIP KEYS (PRIMARY & FOREIGN KEYS)
-- TAKE NOTE OF THE COLUMNS NEEDED AND THE TABLE THE COLUMNS APPEAR 
-- MERGE THE COLUMNS TOGETHER IN THE SELECT STATEMENT
-- STATE THE JOIN TYPE AFTER THE FROM KEYWORD
-- ADD THE SECOND TABLE 
-- INTRODUCE THE JOINING CONDITION = (ON) WITH RELATIONSHIP
-- TO AVOID AMBIGOUS COLUMN:
	-- WE CAN ALIAS OUR TABLES NAMES 
	-- WE USE THE TABLE.COLUMNNAME FOR THE AMBIGOUS COLUMN

-- INNER JOIN
-- GET THE NAMES OF THE EMPLOYEES IN THE COMPANY

SELECT * FROM HumanResources.Employee;
-- JOBTITLE
SELECT * FROM Person.Person;
-- FIRSTNAME, LASTNAME 

-- RELATIONSHIP ==> BUSINESSENTITYID

SELECT FIRSTNAME, LASTNAME, JOBTITLE 
FROM HumanResources.Employee AS HRE
INNER JOIN Person.Person AS PP
ON HRE.BusinessEntityID = PP.BusinessEntityID;

SELECT PP.FIRSTNAME, PP.LASTNAME, HRE.JOBTITLE 
FROM HumanResources.Employee AS HRE
INNER JOIN Person.Person AS PP
ON HRE.BusinessEntityID = PP.BusinessEntityID


--OUTER
--LEFT OUTER JOIN
-- ==> GET ALL THE CUSTOMERS INFO WHETHER THEY HAVE ORDERED OR NOT 

-- GET INFO OF CUSTOMERS
SELECT * FROM Sales.Customer
-- CUSTOMERID,

SELECT * FROM SALES.SALESORDERHEADER
-- SALESORDERNUMBER, CUSTOMERID, PURCHASEORDERNUMBER, TOTALDUE

-- RELATIONSHIP==> CUSTOMERID

SELECT SC.CUSTOMERID, SALESORDERNUMBER, SOH.CUSTOMERID, PURCHASEORDERNUMBER, TOTALDUE
FROM SALES.CUSTOMER AS SC
LEFT OUTER JOIN SALES.SalesOrderHeader AS SOH
ON SC.CustomerID = SOH.CustomerID

SELECT SC.CUSTOMERID, SALESORDERNUMBER,  PURCHASEORDERNUMBER, TOTALDUE
FROM SALES.CUSTOMER AS SC
LEFT OUTER JOIN SALES.SalesOrderHeader AS SOH
ON SC.CustomerID = SOH.CustomerID


-- UNIONS
-- THEY ARE PART OF SET OPERATORS ( UNION, INTERSECT, MINUS/EXCEPT)
-- UNION IS USED TO MERGE/COMBINE THE RESULT OF TWO OR MORE SELECT STATEMENT 

-- RULES
-- no of columns must be the same
-- order of columns must be the same 
-- datatypes of the columns must be the same

-- UNION -- GIVES ONLY THE DISTINCT VALUES  
-- UNION ALL -- GIVE ALL THE VALUES

SELECT * FROM DAFI_APRIL_COHORT
UNION ALL
SELECT * FROM DAFI_MARCH_COHORT

SELECT STUDENT_NO FROM DAFI_APRIL_COHORT 
UNION ALL
SELECT STUDENT_NO FROM DAFI_MARCH_COHORT 

SELECT STUDENT_NO FROM DAFI_APRIL_COHORT 
UNION
SELECT STUDENT_NO FROM DAFI_MARCH_COHORT 

-- DATA DEFINITION LANGUAGES
-- THEY ARE USED TO DEFINE OBJECT
-- OBJECT ==> DATABASE, SCHEMA, TABLES.

-- CREATE ==> TO CREATE OBJECTS 
-- CREATE A DATABASE
CREATE DATABASE QUANTUM_ANALYTICS;

-- LETS CREATE A DATABASE FOR QUANTUM ANALYTICS 
CREATE DATABASE QUANTUM_ANALYTICS;
--TO CREATE A SCHEMA
CREATE SCHEMA DAFI;

-- TO CREATE A TABLE 
-- CREATE TABLES 
-- 01: WE USE THE SYNTAX = CREATE TABLE TABLENAME ()
-- 02: WE ADD THE COLUMN NAMES WITHIN THE BRACKETS
-- 03: WE ADD THE DATATYPES TO EACH COLUMN
-- 04: WE SPECIFY RELATIONSHIP (PRIMARY, ETC)
-- 05: WE ADD CONSTRAINT (UNIQUE, NOT NULL, IDENTITY)
-- IDENTITY = USED TO AUTOMATE VALUES E.G 1,2,3,4,5

-- LETS CREATE A TABLE INSIDE THE QUANTUM ANALYTICS DATABASE
USE QUANTUM_ANALYTICS;


CREATE TABLE DAFI_APRIL_COHORT(
	STUDENT_NO INT PRIMARY KEY IDENTITY(1,1),
	STUDENT_NAME VARCHAR(20) NOT NULL,
	STUDENT_LOC VARCHAR(10) 
	);



-- ALTER
-- USED TO ALTER THE STRUCTURE OF COLUMNS OF A TABLE IN THE DATABASE
-- E.G TO ADD AN ADDITIONAL COLUMN TO A DATABASE, MODIFY A COLUMN, DROP A COLUMN
ALTER TABLE APRIL_COHORT
	ADD LOCATION VARCHAR(20) ;

ALTER TABLE APRIL_COHORT
	ADD LOCATION CHAR(20) ;

	-- LETS ADD GENDER TO OUR DAFI_APRI_COHORT TABLE
ALTER TABLE DAFI_APRIL_COHORT
	ADD GENDER VARCHAR(1);

	SELECT * FROM DAFI_APRIL_COHORT;
-- DROP 

-- USED TO DELETE OBJECT 
-- DROP DATABASE
--DROP DATABASE QUANTUM_ANALYTICS;
-- DROP SCHEMA
-- DROP TABLE
--DROP TABLE DAFI_APRIL_COHORT;
 
-- DATA MANUIPULATION LANGUAGE
-- USED TO MANIPULATE THE DATA IN THE TABLES

-- INSERT
-- USED TO INSERT RECRODS INTO A TABLE 

-- INSERT INTO THE DAFI_APRIL_COHORT TABLE 
SELECT * FROM DAFI_APRIL_COHORT;

-- UPDATE 
-- USED TO UPDATE THE RECRODS WITHIN A TABLE
UPDATE DAFI_APRIL_COHORT
SET GENDER = 'X'
WHERE STUDENT_NO = 4;

-- DELETE 
-- USED TO DELETE A RECORD IN THE TABLE 

DELETE FROM DAFI_APRIL_COHORT
WHERE STUDENT_NO = 4;

-- MISCELLENUOS
-- youtube!!!
-- google 
-- w3schools


-- END THE CLASS
-- connect with me on linkedin
-- Abdullah Bankole
-- https://www.linkedin.com/in/abdullahbankole/

